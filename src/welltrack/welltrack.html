<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdn.tailwindcss.com;
        style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://fonts.googleapis.com;
        font-src 'self' https://fonts.gstatic.com;
        img-src 'self' data:;
        connect-src 'self' https://cdn.jsdelivr.net;
        object-src 'none';
        base-uri 'self';
        form-action 'self';
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WellTrack Gesundheitstagebuch</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6750A4">
    <link rel="apple-touch-icon" href="icon-192.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet">
    <style>
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;
            --md-sys-color-secondary: #625B71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1D192B;
            --md-sys-color-tertiary: #7D5260;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #FFD8E4;
            --md-sys-color-on-tertiary-container: #31111D;
            --md-sys-color-error: #B3261E;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #F9DEDC;
            --md-sys-color-on-error-container: #410E0B;
            --md-sys-color-background: #FFFBFE;
            --md-sys-color-on-background: #1C1B1F;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-on-surface-variant: #49454F;
            --md-sys-color-outline: #79747E;
            --md-sys-color-surface-container-highest: #E6E0E9;
            --md-sys-color-surface-container-low: #F7F2FA;
            --md-sys-color-warning: #FFC107;
        }

        html { scroll-behavior: smooth; }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            /* font-size: 125%; */
        }
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
            vertical-align: bottom;
        }
        .card {
            background-color: var(--md-sys-color-surface-container-low);
            border: 1px solid var(--md-sys-color-surface-variant);
            border-radius: 2px;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            padding-top: 1rem;
            padding-bottom: 1rem;
        }
        .pill-card {
            background-color: var(--md-sys-color-surface-container-low);
            border: 1px solid var(--md-sys-color-surface-variant);
            border-radius: 9999px; /* This creates the pill shape */
            padding: 0.75rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            transition: all 0.2s;
            cursor: pointer;
        }
        .pill-card:hover {
            box-shadow: 0 2px 8px 2px rgba(0,0,0,.1);
            transform: translateY(-1px);
        }
        .fab {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-radius: 1.5rem;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px 3px rgba(0,0,0,.15), 0 1px 3px rgba(0,0,0,.3);
            transition: all 0.2s ease-in-out;
        }
        .fab:hover {
             box-shadow: 0 6px 12px 4px rgba(0,0,0,.15), 0 2px 4px rgba(0,0,0,.3);
             transform: translateY(-2px);
        }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-weight: 500;
            transition: all 0.2s;
            cursor: pointer;
        }
        .btn:disabled {
            background-color: var(--md-sys-color-surface-variant) !important;
            color: var(--md-sys-color-on-surface-variant) !important;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .btn-primary { background-color: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); }
        .btn-primary:hover:not(:disabled) { background-color: #5a4293; }
        .btn-secondary { background-color: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container); }
        .btn-secondary:hover:not(:disabled) { background-color: #dcd3f0; }
        .btn-tertiary { border: 1px solid var(--md-sys-color-outline); color: var(--md-sys-color-primary); }
        .btn-tertiary:hover:not(:disabled) { background-color: var(--md-sys-color-surface-container-low); }
        .btn-warning { background-color: var(--md-sys-color-warning); color: var(--md-sys-color-on-background); }
        .btn-error { background-color: var(--md-sys-color-error-container); color: var(--md-sys-color-on-error-container); }
        .btn-error:hover:not(:disabled) { background-color: #f8c8c6; }
        .btn-error-primary { background-color: var(--md-sys-color-error); color: var(--md-sys-color-on-error); }
        .btn-error-primary:hover:not(:disabled) { background-color: #f87e78; }
        .btn-sm { 
            padding: 0.25rem 0.75rem !important;
            font-size: 0.875rem;
        }

        .h2-style {
            font-size: 1.25rem; /* 20px */
            font-weight: 600;
            color: #4A5568; /* gray-700 */
        }

        .day-btn.selected { background-color: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border-color: var(--md-sys-color-primary); }
        .view-toggle-btn.active { background-color: var(--md-sys-color-primary-container); color: var(--md-sys-color-on-primary-container); border-color: var(--md-sys-color-primary-container); z-index: 10; }
        
        .body-part { fill: var(--md-sys-color-surface-container-highest); stroke: var(--md-sys-color-outline); stroke-width: 0.5; cursor: pointer; transition: fill 0.2s ease-in-out; }
        .body-part:hover { fill: var(--md-sys-color-primary-container); }
        .svg-label { font-size: 8px; font-family: 'Roboto', sans-serif; fill: var(--md-sys-color-on-surface-variant); pointer-events: none; text-anchor: middle; }
        .label { font-family: 'Roboto', sans-serif; font-size: 16px; font-weight: 500; fill: #5F6368; pointer-events: none; text-anchor: middle; dominant-baseline: central; transition: fill 0.2s ease-in-out; }
        .body-part.selected + .label { fill: #FFFFFF; }
        
        .nav-btn {
            padding: 8px;
            border-radius: 99px;
            transition: all 0.2s;
        }
        .nav-btn.active {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
        }
        .nav-btn:not(.active):hover {
             background-color: var(--md-sys-color-surface-container-low);
        }
        
        /* Mood Slider Styles */
        .mood-slider-wrapper {
            position: relative;
            height: 40px; /* Increased height for easier clicking */
            cursor: pointer;
        }
        .mood-slider-ruler {
            position: absolute;
            height: 8px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
            background-image: linear-gradient(to right, #ef4444, #f97316, #fbbf24 49%, #bfdbfe 51%, #60a5fa, #22c55e);
            border-radius: 4px;
        }
        .mood-slider-tick-container {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: 24px;
            width: calc(100% - 4px);
            left: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }
        .mood-slider-tick {
            width: 4px;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.6);
            border-radius: 2px;
        }
        .mood-slider-default-indicator {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #facc15;
            display: none;
            z-index: 3;
            pointer-events: none;
        }
        input[type=range].mood-slider {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            position: relative;
            z-index: 2;
            margin: 0;
            height: 100%;
        }
        input[type=range].mood-slider.is-default + .mood-slider-default-indicator {
            display: inline-block;
        }
        input[type=range].mood-slider.is-default {
            pointer-events: none;
        }
        input[type=range].mood-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 32px;
            width: 32px;
            border-radius: 50%;
            background: var(--md-sys-color-primary);
            cursor: pointer;
            border: 5px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            transition: opacity 0.2s ease-in-out;
        }
        input[type=range].mood-slider.is-default::-webkit-slider-thumb {
            opacity: 0;
            pointer-events: none;
        }

        input[type=range].mood-slider::-moz-range-thumb {
            height: 32px;
            width: 32px;
            border-radius: 50%;
            background: var(--md-sys-color-primary);
            cursor: pointer;
            border: 5px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            transition: opacity 0.2s ease-in-out;
        }
        input[type=range].mood-slider.is-default::-moz-range-thumb {
            opacity: 0;
            pointer-events: none;
        }
        .history-tab-group .history-tab.active {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-color: var(--md-sys-color-primary-container);
            z-index: 10;
        }
        .settings-tab-content {
            display: none;
        }
        .settings-tab-content.active {
            display: block;
        }
        .submenu-container {
            display: flex;
            flex-wrap: wrap-reverse;
            align-items: center;
            justify-content: flex-end;
            gap: 0.25rem;
        }
    </style>
</head>
<body class="antialiased">

    <!-- Header -->
    <header class="sticky top-0 z-20 bg-white/80 backdrop-blur-md border-b border-gray-200">
        <div class="container mx-auto max-w-4xl px-4 py-3 flex justify-between items-center">
            <div id="header-left">
                <button id="nav-today" onclick="WellTrackApp.events.showPage('today')" class="nav-btn">
                    <span class="material-symbols-outlined text-3xl">home</span>
                </button>
            </div>
            <div id="header-right">
                 <nav id="main-nav" class="flex items-center gap-2">
                    <button id="nav-event" onclick="WellTrackApp.events.showPage('event')" class="nav-btn rounded-full" title="Ereignis eintragen">
                        <span class="material-symbols-outlined">checklist</span>
                    </button>
                     <button id="nav-mood" onclick="WellTrackApp.events.showPage('mood')" class="nav-btn rounded-full" title="Stimmung eintragen">
                        <span class="material-symbols-outlined">sentiment_satisfied</span>
                    </button>
                     <button id="nav-pain" onclick="WellTrackApp.events.showPage('pain')" class="nav-btn rounded-full" title="Schmerzen eintragen">
                        <span class="material-symbols-outlined">personal_injury</span>
                    </button>
                    <button id="nav-history" onclick="WellTrackApp.events.showPage('history')" class="nav-btn rounded-full" title="Verlauf">
                        <span class="material-symbols-outlined">timeline</span>
                    </button>
                    <button id="nav-log" onclick="WellTrackApp.events.showPage('log')" class="nav-btn rounded-full" title="Protokoll">
                        <span class="material-symbols-outlined">history</span>
                    </button>
                    <button id="nav-settings" onclick="WellTrackApp.events.showPage('settings')" class="nav-btn rounded-full" title="Einstellungen">
                        <span class="material-symbols-outlined">menu</span>
                    </button>
                </nav>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main id="app-container" class="container mx-auto max-w-4xl px-1 pb-4 md:pb-6">
        <!-- Page content will be dynamically inserted here -->
    </main>
    
    <!-- Version Update Overlay -->
    <div id="version-overlay" class="hidden bg-gray-800 text-white p-4 rounded-lg shadow-lg z-50 flex justify-center items-center gap-3 transition-opacity duration-300 opacity-100">
        <span class="material-symbols-outlined">celebration</span>
        <span id="version-overlay-text"></span>
    </div>

    <!-- General Notification Overlay -->
    <div id="notification-overlay" class="hidden bg-gray-800 text-white p-4 rounded-lg shadow-lg z-50 flex justify-center items-center gap-3 transition-opacity duration-300 opacity-100">
        <span id="notification-overlay-icon" class="material-symbols-outlined">info</span>
        <span id="notification-overlay-text"></span>
    </div>

    <!-- Modal Structure -->
    <div id="modal-container" onclick="if (event.target === this) { WellTrackApp.render.modal.hide() }" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div id="modal-content" class="bg-white rounded-3xl p-6 shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto">
            <!-- Modal content will be dynamically inserted here -->
        </div>
    </div>

<script>
// Main application object
const WellTrackApp = {
    // --- STATE ---
    // Holds the dynamic state of the application
    state: {
        activePage: 'today', // today, event, mood, pain, history, log, settings
        currentPainPart: null,
        charts: {}, // pain, event, mood will be dynamically populated
        currentPage: 1,
        currentEditingEvent: null,
        timeRange: 7,
        notificationPermission: Notification.permission,
        activeMoodGroup: 'arousal_level',
        activeEventGroup: null, // Set to null initially, will be set to first group on page load
        activeHistoryTab: 'event',
        activeSettingsTab: 'eventTypes', // eventTypes, data, reminders, about
        isTodaysLogVisible: false,
        sliderClickStartPosition: null,
        currentPainView: 'back',
        currentLogWeekStart: null
    },

    // --- CONFIGURATION ---
    // Static configuration and UI strings
    config: {
        DEFAULT_BODY_COLOR: '#E6E0E9',
        PAIN_LEVELS: {
            0: { label: "Kein Schmerz", short: "-", color: "#86efac" },
            1: { label: "Leicht", short: "L", color: "#bfdbfe" },
            2: { label: "Unangenehm", short: "U", color: "#fde047" },
            3: { label: "Stark", short: "S", color: "#fb923c" },
            4: { label: "Fürchterlich", short: "F", color: "#ef4444" },
            5: { label: "Vernichtend", short: "X", color: "#9333ea" },
        },
        CHART_FONT_OPTIONS: {
            font: { size: 12, weight: 'bold' }
        },
        DEFAULT_EVENTS_JSON: `[
            {"name": "Spaziergang", "activity": "walking", "displayType": 0, "increment": 15, "unitType": "min", "groupType": "Bewegung"},
            {"name": "Kaffee Tassen", "activity": "coffee_cups", "displayType": 1, "increment": 1, "unitType": "", "groupType": "Ernährung"},
            {"name": "Ibuprofen 400mg", "activity": "ibuprofen_400", "displayType": 2, "increment": 0, "unitType": "", "groupType": "Medikamente"},
            {"name": "Rückenübungen", "activity": "back_exercises", "displayType": 0, "increment": 15, "unitType": "min", "groupType": "Bewegung"}
        ]`,
        MOOD_GROUPS: {
            'arousal_level': {
                name: 'Energie & Motivation',
                questions: [
                    { id: 'energy', name: 'Energie', negative: 'Müde / Kraftlos', positive: 'Energiegeladen' },
                    { id: 'motivation', name: 'Motivation', negative: 'Lethargisch', positive: 'Motiviert' },
                    { id: 'inner_drive', name: 'Innere Unruhe', negative: 'Getrieben', positive: 'Zentriert' },
                    { id: 'temperament', name: 'Temperament', negative: 'Geladen / Gereizt', positive: 'Gelassen' },
                    { id: 'anxiety', name: 'Angstfreiheit', negative: 'Ängstlich', positive: 'Ruhig/Frei' },
                    { id: 'focus', name: 'Fokus', negative: 'Abgelenkt', positive: 'Fokussiert' }
                ]
            },
            'affective_state': {
                name: 'Stimmung & Selbstwert',
                questions: [
                    { id: 'happiness', name: 'Glücklichkeit', negative: 'Deprimiert', positive: 'Glücklich' },
                    { id: 'outlook', name: 'Ausblick / Hoffnung', negative: 'Hoffnungslos', positive: 'Hoffnungsvoll' },
                    { id: 'self_esteem', name: 'Selbstwert', negative: 'Wertlos', positive: 'Wertvoll' },
                    { id: 'stability', name: 'Stabilität', negative: 'Labil', positive: 'Stabil' },
                    { id: 'social_connection', name: 'Soziale Verbindung', negative: 'Zurückgezogen', positive: 'Engagiert' }
                ]
            }
        },
        MOOD_VALUE_MAP: [-3, -2, -1, 1, 2, 3]
    },

    // --- INITIALIZATION ---
    init() {
        let settings = this.data.getSettings();
        let settingsUpdated = false;

        // One-time migration for users with old settings structure
        const oldEventTypesData = localStorage.getItem('wellTrackEvents');
        if (oldEventTypesData) {
            const newEventTypesData = localStorage.getItem('wellTrackEventTypes');
            if (!newEventTypesData) {
                localStorage.setItem('wellTrackEventTypes', oldEventTypesData);
            }
            localStorage.removeItem('wellTrackEvents');
        }
        const oldPainView = localStorage.getItem('wellTrackPainView');
        if (oldPainView) {
            settings.painView = oldPainView;
            localStorage.removeItem('wellTrackPainView');
            settingsUpdated = true;
        }
        const oldLogVisibility = localStorage.getItem('wellTrackLogVisibility');
        if (oldLogVisibility) {
            settings.logVisibility = JSON.parse(oldLogVisibility);
            localStorage.removeItem('wellTrackLogVisibility');
            settingsUpdated = true;
        }
        const oldSettingsTab = localStorage.getItem('wellTrackActiveSettingsTab');
        if (oldSettingsTab) {
            settings.activeSettingsTab = oldSettingsTab;
            localStorage.removeItem('wellTrackActiveSettingsTab');
            settingsUpdated = true;
        }

        if (settingsUpdated) {
            this.data.saveSettings(settings);
        }

        // Initialize state from settings
        this.state.currentPainView = settings.painView;
        this.state.isTodaysLogVisible = settings.logVisibility;
        this.state.activeSettingsTab = settings.activeSettingsTab;

        document.addEventListener('DOMContentLoaded', () => {
            this.events.showPage(this.state.activePage);
            this.events.initEventListeners();
            this.events.registerServiceWorker();
            this.events.checkVersion();
        });
    },

    // --- DATA MANAGEMENT ---
    data: {
        getSettings() {
            let settings = JSON.parse(localStorage.getItem('wellTrackSettings')) || {};
            const defaults = {
                reminderTimes: '',
                reminders_active: false,
                painView: 'back',
                logVisibility: false,
                activeSettingsTab: 'eventTypes',
                welltrack_latest: ''
            };
            return { ...defaults, ...settings };
        },
        saveSettings(settings) {
            localStorage.setItem('wellTrackSettings', JSON.stringify(settings));
        },
        getExportableData() {
            return {
                metrics: this.getMetrics(),
                eventTypes: this.getEventTypes(),
                settings: this.getSettings()
            };
        },
        addMetric(entry) {
            let metrics = this.getMetrics();
            const now = Date.now();

            if (entry.metric.startsWith('event_') && !entry.metric.endsWith('_timestamp')) {
                // For incrementing events, find and replace the entry for the same activity today.
                const startOfToday = new Date();
                startOfToday.setHours(0, 0, 0, 0);
                const existingIndex = metrics.findIndex(oldEntry =>
                    oldEntry.labels.activity === entry.labels.activity &&
                    oldEntry.timestamp >= startOfToday.getTime()
                );
                if (existingIndex > -1) {
                    metrics.splice(existingIndex, 1);
                }
            } else if (entry.metric.startsWith('mood_') || entry.metric.startsWith('pain_')) {
                // For mood/pain, find and replace the entry for the same metric in the last 10 minutes.
                const tenMinutesAgo = now - 600000;
                let foundIndex = -1;
                // Search from the end for performance.
                for (let i = metrics.length - 1; i >= 0; i--) {
                    const oldEntry = metrics[i];
                    if (oldEntry.timestamp < tenMinutesAgo) break; // Optimization
                    if (oldEntry.metric === entry.metric) {
                        foundIndex = i;
                        break;
                    }
                }
                if (foundIndex > -1) {
                    metrics.splice(foundIndex, 1);
                }
            }

            // Only add entry if it has a non-zero value, or it's a timestamp event.
            if ((entry.value !== 0) || entry.metric.endsWith('_timestamp')) {
                 metrics.push(entry);
            }

            this.saveMetrics(metrics);
        },
        getMetrics() {
            // Sort metrics by timestamp on load to ensure index is always correct
            const metrics = JSON.parse(localStorage.getItem('wellTrackMetrics')) || [];
            return metrics.sort((a, b) => a.timestamp - b.timestamp);
        },
        saveMetrics(metrics) {
            localStorage.setItem('wellTrackMetrics', JSON.stringify(metrics));
            if(WellTrackApp.state.activePage === 'today') WellTrackApp.render.todayPage();
        },
        getEventTypes() {
            const eventTypes = localStorage.getItem('wellTrackEventTypes');
            const processEvents = (eventArray) => {
                return eventArray.map(e => {
                    let newEvent = { ...e };
                    // Migration from is_cumulative to displayType
                    if (newEvent.is_cumulative !== undefined) {
                        newEvent.displayType = newEvent.is_cumulative ? 0 : 1;
                        delete newEvent.is_cumulative;
                    }
                    // Set default if it's still missing
                    if (newEvent.displayType === undefined) {
                        newEvent.displayType = 0;
                    }

                    newEvent.groupType = newEvent.groupType || '';
                    delete newEvent.days; // Ensure 'days' is removed
                    return newEvent;
                });
            };

            if (eventTypes) {
                const parsedEvents = JSON.parse(eventTypes);
                const updatedEvents = processEvents(parsedEvents);
                // If migration happened, save it back
                if (JSON.stringify(parsedEvents) !== JSON.stringify(updatedEvents)) {
                    this.saveEventTypes(updatedEvents);
                }
                return updatedEvents;
            } else {
                const defaultEvents = processEvents(JSON.parse(WellTrackApp.config.DEFAULT_EVENTS_JSON));
                this.saveEventTypes(defaultEvents);
                return defaultEvents;
            }
        },
        saveEventTypes(eventTypes) {
            localStorage.setItem('wellTrackEventTypes', JSON.stringify(eventTypes));
        },
        loadTodaysState() {
            const page = WellTrackApp.state.activePage;
            const metrics = this.getMetrics();
            const todaysMetrics = metrics.filter(e => WellTrackApp.utils.isToday(new Date(e.timestamp)));
            const now = Date.now();
           
            if (page === 'pain') {
                const todaysPainMetrics = todaysMetrics.filter(e => e.metric.startsWith('pain_'));
                const lastPainFreeEntry = todaysPainMetrics.find(m => m.metric === 'pain_free_level');
                const isPainFreeActive = lastPainFreeEntry && (now - lastPainFreeEntry.timestamp < 600000);

                document.querySelectorAll('.pain-free-btn circle').forEach(circle => {
                    circle.style.fill = isPainFreeActive ? '#86efac' : WellTrackApp.config.DEFAULT_BODY_COLOR;
                });

                document.querySelectorAll('.body-part').forEach(part => {
                    if (isPainFreeActive) {
                        part.style.fill = WellTrackApp.config.DEFAULT_BODY_COLOR;
                        delete part.dataset.level;
                    } else {
                        const latestEntry = todaysPainMetrics.filter(m => m.labels.body_part === part.id).pop();
                        if (latestEntry && (now - latestEntry.timestamp < 600000)) {
                            part.style.fill = WellTrackApp.config.PAIN_LEVELS[latestEntry.value].color;
                            part.dataset.level = latestEntry.value;
                        } else {
                            part.style.fill = WellTrackApp.config.DEFAULT_BODY_COLOR;
                            delete part.dataset.level;
                        }
                    }
                });
            } else if (page === 'mood') {
                const todaysMoodMetrics = todaysMetrics.filter(e => e.metric.startsWith('mood_'));
                if (!WellTrackApp.state.activeMoodGroup) {
                    WellTrackApp.state.activeMoodGroup = 'arousal_level';
                }

                const activeGroup = WellTrackApp.config.MOOD_GROUPS[WellTrackApp.state.activeMoodGroup];
                if(activeGroup){
                    activeGroup.questions.forEach(q => {
                        const slider = document.getElementById(`mood-slider-${q.id}`);
                        if(slider){
                            const latestEntry = todaysMoodMetrics.filter(m => m.labels.mood_id === q.id).pop();
                            let sliderValue = -1;
                            if (latestEntry && (now - latestEntry.timestamp < 600000)) {
                                sliderValue = WellTrackApp.config.MOOD_VALUE_MAP.indexOf(latestEntry.value);
                            }
                            
                            if (sliderValue !== -1) {
                                slider.value = sliderValue;
                                slider.classList.remove('is-default');
                            } else {
                                slider.value = 2.5; // Visually center it, but it's hidden
                                slider.classList.add('is-default');
                            }
                        }
                    });
                }
            }
        },
        exportData() {
            const dataToExport = this.getExportableData();
            const dataStr = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `welltrack_export_${Date.now()}.json`;
            a.click(); URL.revokeObjectURL(url);
            WellTrackApp.events.showNotification("Daten exportiert", "download");
        },
        importData(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);

                    const isValidStructure = 
                        imported &&
                        Array.isArray(imported.metrics) && 
                        (Array.isArray(imported.eventTypes) || Array.isArray(imported.events)) &&
                        typeof imported.settings === 'object' && 
                        imported.settings !== null;

                    if (!isValidStructure) {
                         WellTrackApp.render.modal.showAlert('Fehler', 'Die Importdatei hat ein ungültiges Grundformat oder es fehlen erforderliche Daten (metrics, events oder eventTypes, settings).');
                         event.target.value = '';
                         return;
                    }

                    // Backwards compatibility for "events" key
                    if (imported.events) {
                        imported.eventTypes = imported.events;
                        delete imported.events;
                    }

                    for(const metric of imported.metrics) {
                        if (typeof metric.metric !== 'string' || typeof metric.timestamp !== 'number' || typeof metric.labels !== 'object' || metric.labels === null) {
                            WellTrackApp.render.modal.showAlert('Fehler', `Ein Metrik-Eintrag in der Importdatei ist ungültig. Fehlerhafter Eintrag: ${JSON.stringify(metric)}`);
                            event.target.value = '';
                            return;
                        }
                    }

                    const overwriteData = () => {
                        const importedMetricsCount = imported.metrics?.length || 0;
                        const importedEventTypesCount = imported.eventTypes?.length || 0;
                        this.saveMetrics(imported.metrics || []);
                        this.saveEventTypes(imported.eventTypes || []);
                        this.saveSettings(imported.settings || {});
                        WellTrackApp.render.modal.hide();
                        WellTrackApp.events.showNotification(`Daten überschrieben: ${importedEventTypesCount} Ereignisarten und ${importedMetricsCount} Metriken importiert.`, 'file_upload');
                        location.reload();
                    };

                    const appendData = () => {
                        // 1. Append Event Types without overwriting
                        const currentEvents = this.getEventTypes();
                        const importedEvents = imported.eventTypes || [];
                        const currentEventActivities = new Set(currentEvents.map(e => e.activity));
                        const newEventTypes = importedEvents.filter(e => !currentEventActivities.has(e.activity));

                        if (newEventTypes.length > 0) {
                             const finalEvents = [...currentEvents, ...newEventTypes];
                             this.saveEventTypes(finalEvents);
                        }
                        const eventsByActivity = new Map(this.getEventTypes().map(e => [e.activity, e]));

                        // 2. Merge Metrics with reconstructed labels
                        const currentMetrics = this.getMetrics();
                        const importedMetrics = imported.metrics || [];

                        const existingMetricKeys = new Set(currentMetrics.map(m => `${m.timestamp}|${m.metric}`));

                        const newMetrics = [];
                        importedMetrics.forEach(metric => {
                            const key = `${metric.timestamp}|${metric.metric}`;
                            if (!existingMetricKeys.has(key)) {
                                let newMetric = { ...metric, labels: {} }; // Start with fresh labels

                                if (metric.metric.startsWith('event_')) {
                                    const activity = metric.labels.activity;
                                    const eventConfig = eventsByActivity.get(activity);
                                    if (eventConfig) {
                                        // Reconstruct labels from current event config
                                        newMetric.labels = {
                                            activity: eventConfig.activity,
                                            name: eventConfig.name,
                                            unitType: eventConfig.unitType,
                                            groupType: eventConfig.groupType || ''
                                        };
                                    } else {
                                        return; // Skip metric if its event type doesn't exist
                                    }
                                } else {
                                    // For non-event metrics (mood, pain), keep original labels
                                    newMetric.labels = metric.labels;
                                }
                                newMetrics.push(newMetric);
                                existingMetricKeys.add(key); // Add to set to handle duplicates within the import file
                            }
                        });

                        if (newMetrics.length > 0) {
                            const mergedMetrics = [...currentMetrics, ...newMetrics].sort((a, b) => a.timestamp - b.timestamp);
                            this.saveMetrics(mergedMetrics);
                        }

                        // 3. Settings are not merged on append.
                        WellTrackApp.render.modal.hide();
                        WellTrackApp.events.showNotification(`Daten vereint: ${newEventTypes.length} neue Ereignisarten und ${newMetrics.length} neue Metriken importiert.`, 'merge_type');
                        location.reload();
                    };

                    const content = `
                        <h3 class="text-3xl font-medium mb-4">Daten importieren</h3>
                        <p class="mb-6 text-xl">Wählen Sie, wie die Daten aus der Datei importiert werden sollen. Diese Aktion kann nicht rückgängig gemacht werden.</p>
                        <div class="flex flex-col gap-3">
                            <button id="import-overwrite-btn" class="btn btn-error-primary w-full text-xl py-3">Daten überschreiben</button>
                            <button id="import-append-btn" class="btn btn-error w-full text-xl py-3">Daten vereinen</button>
                            <button onclick="WellTrackApp.render.modal.hide()" class="btn btn-tertiary w-full mt-4 text-xl py-3">Abbrechen</button>
                        </div>
                    `;
                    WellTrackApp.render.modal.show(content, { modalClass: 'w-full' });
                    document.getElementById('import-overwrite-btn').onclick = overwriteData;
                    document.getElementById('import-append-btn').onclick = appendData;

                } catch (err) { WellTrackApp.render.modal.showAlert('Fehler', `Die Datei konnte nicht gelesen oder verarbeitet werden: ${err.message}`); }
            };
            reader.readAsText(file); event.target.value = '';
        },
    },

    // --- UI RENDERING ---
    render: {
        todayPage() {
            const container = document.getElementById('app-container');
            container.innerHTML = this.components.todaySection();

            // --- Data fetching ---
            const allData = WellTrackApp.data.getMetrics();
            const todaysMetrics = allData.filter(e => WellTrackApp.utils.isSameDay(new Date(e.timestamp), new Date()));
            const summarizedToday = WellTrackApp.utils.summarizeMetrics(todaysMetrics);

            // --- Deltas ---
            const renderArrowDelta = (delta, higherIsGood = true) => {
                if (delta === null || isNaN(delta)) {
                    return `<span class="text-lg text-gray-500 font-semibold inline-flex items-center gap-1">
                                <span class="material-symbols-outlined text-xl">horizontal_rule</span>
                            </span>`;
                }
                if (delta === 0) {
                    return `<span class="text-lg text-gray-500 font-semibold inline-flex items-center gap-1">
                                <span class="material-symbols-outlined text-xl">trending_flat</span>
                            </span>`;
                }

                const isGood = higherIsGood ? (delta > 0) : (delta < 0);
                const color = isGood ? 'text-green-500' : 'text-red-500';
                const icon = delta > 0 ? 'trending_up' : 'trending_down';

                return `<span class="text-lg ${color} font-semibold inline-flex items-center gap-1">
                            <span class="material-symbols-outlined text-xl">${icon}</span>
                            ${Math.abs(Math.round(delta))}
                        </span>`;
            };

            // --- Render Mood and Pain Cards ---
            const summaryContainer = document.getElementById('today-summary-cards');

            const { latestSlot: latestPainSlot, previousSlot: previousPainSlot } = WellTrackApp.utils.getMetricSlots('pain_');
            const painDelta = (latestPainSlot !== null && previousPainSlot !== null) ? latestPainSlot - previousPainSlot : null;
            const displayPainValue = latestPainSlot !== null ? latestPainSlot : '-';

            const { latestSlot: latestMoodSlot, previousSlot: previousMoodSlot } = WellTrackApp.utils.getMetricSlots('mood_');
            const moodDelta = (latestMoodSlot !== null && previousMoodSlot !== null) ? latestMoodSlot - previousMoodSlot : null;
            const displayMoodValue = latestMoodSlot !== null ? latestMoodSlot : '-';

            summaryContainer.innerHTML = `
                <div class="pill-card !p-0 overflow-hidden">
                    <div onclick="WellTrackApp.events.showPage('mood')" class="w-1/2 h-full flex items-center justify-start pl-6 pr-2 py-4 cursor-pointer hover:bg-gray-200/50 transition-colors">
                        <p class="text-xl font-bold">Stimmung</p>
                    </div>
                    <div onclick="WellTrackApp.events.showHistoryFor('mood')" class="w-1/2 h-full flex items-baseline justify-end gap-3 pr-6 pl-2 py-4 cursor-pointer hover:bg-gray-200/50 transition-colors">
                        <p class="text-5xl font-bold">${displayMoodValue}</p>
                        ${renderArrowDelta(moodDelta, true)}
                    </div>
                </div>
                <div class="pill-card !p-0 overflow-hidden">
                     <div onclick="WellTrackApp.events.showPage('pain')" class="w-1/2 h-full flex items-center justify-start pl-6 pr-2 py-4 cursor-pointer hover:bg-gray-200/50 transition-colors">
                        <p class="text-xl font-bold">Schmerz</p>
                    </div>
                    <div onclick="WellTrackApp.events.showHistoryFor('pain')" class="w-1/2 h-full flex items-baseline justify-end gap-3 pr-6 pl-2 py-4 cursor-pointer hover:bg-gray-200/50 transition-colors">
                       <p class="text-5xl font-bold">${displayPainValue}</p>
                       ${renderArrowDelta(painDelta, false)}
                    </div>
                </div>
            `;

            // --- Render Event Group Cards ---
            const eventGroupsContainer = document.getElementById('today-event-groups');
            const allEvents = WellTrackApp.data.getEventTypes();
            const todaysEventMetrics = todaysMetrics.filter(e => e.metric.startsWith('event_'));

            const displayItems = [];
            const processedActivities = new Set();

            // Define cumulative groups (displayType 0)
            const cumulativeGroups = {};
            allEvents
                .filter(e => e.displayType === 0 && e.groupType && e.unitType && e.unitType.length > 2)
                .forEach(e => {
                    const key = `${e.groupType}|${e.unitType}`;
                    if (!cumulativeGroups[key]) {
                        cumulativeGroups[key] = {
                            isGroup: true, name: e.groupType, unit: e.unitType,
                            groupKey: e.groupType, activities: []
                        };
                    }
                    cumulativeGroups[key].activities.push(e.activity);
                });

            Object.values(cumulativeGroups).forEach(group => {
                displayItems.push(group);
                group.activities.forEach(act => processedActivities.add(act));
            });

            // Add highlighted individual events (displayType 1) that have a value today
            allEvents
                .filter(e => !processedActivities.has(e.activity) && e.displayType === 1)
                .forEach(event => {
                    const itemMetrics = todaysEventMetrics.filter(m => m.labels.activity === event.activity);

                    let totalValue = 0;
                    if (event.increment === 0) { // Timestamp event
                        totalValue = itemMetrics.length;
                    } else { // Cumulative event
                        const metric = WellTrackApp.utils.summarizeMetrics(itemMetrics)[0];
                        totalValue = metric ? metric.value : 0;
                    }

                    if (totalValue > 0) {
                        displayItems.push({
                            isGroup: false, name: event.name, unit: event.unitType,
                            groupKey: event.groupType || '*', activities: [event.activity],
                            increment: event.increment
                        });
                    }
                });

            // Render the items
            if (displayItems.length > 0) {
                eventGroupsContainer.innerHTML = displayItems.map(item => {
                    const itemMetrics = todaysEventMetrics.filter(m => item.activities.includes(m.labels.activity));

                    let totalValue = 0;
                    if (item.isGroup) {
                        totalValue = itemMetrics.reduce((sum, m) => sum + m.value, 0);
                    } else {
                        if (item.increment === 0) {
                            totalValue = itemMetrics.length;
                        } else {
                            const metric = WellTrackApp.utils.summarizeMetrics(itemMetrics)[0];
                            totalValue = metric ? metric.value : 0;
                        }
                    }

                    const chartKey = item.isGroup ? `${item.name}-${item.unit}` : item.name;
                    const unitHtml = item.unit ? `<p class="text-base font-medium">${item.unit}</p>` : '';
                    return `
                        <div class="card !p-0 flex justify-between items-stretch overflow-hidden">
                             <div onclick="WellTrackApp.events.showEventPageForGroup('${item.groupKey}')" class="p-4 flex-grow cursor-pointer hover:bg-gray-200/50 transition-colors flex items-center">
                                <p class="text-lg font-semibold">${item.name}</p>
                            </div>
                            <div onclick="WellTrackApp.events.showHistoryForEvent('${chartKey}')" class="p-4 cursor-pointer hover:bg-gray-200/50 transition-colors flex items-center justify-center flex-shrink-0">
                                <div class="flex items-baseline justify-center flex-wrap gap-x-1">
                                    <p class="text-3xl font-bold">${totalValue}</p>
                                    ${unitHtml}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                eventGroupsContainer.innerHTML = '';
            }

            // --- Render Todays Log ---
            const logSection = document.getElementById('todays-log-section');
            const entryCount = summarizedToday.length;
            const isVisible = WellTrackApp.state.isTodaysLogVisible;

            let logHtml = '';

            if (entryCount === 0) {
                logHtml = `
                    <div class="card text-center text-gray-500 font-semibold">
                        Noch keine Einträge für Heute
                    </div>
                `;
            } else {
                const buttonText = `${entryCount} heutige Einträge`;
                const icon = isVisible ? 'expand_less' : 'expand_more';
                const listVisibilityClass = isVisible ? '' : 'hidden';

                let listHtml = '';
                if (isVisible) {
                    summarizedToday.sort((a,b) => b.timestamp - a.timestamp).forEach(metric => {
                        listHtml += `<li class="text-gray-800 py-1 border-b border-gray-200 last:border-b-0">${this.components.todaysLogEntry(metric)}</li>`;
                    });
                }

                logHtml = `
                    <div class="card">
                        <button onclick="WellTrackApp.events.toggleTodaysLog()" class="w-full flex justify-center items-center font-semibold text-gray-800 p-2 rounded-lg hover:bg-gray-200/50">
                            <span>${buttonText}</span>
                            <span class="material-symbols-outlined">${icon}</span>
                        </button>
                        <ul id="todays-log-container" class="space-y-1 mt-2 px-2 ${listVisibilityClass}">
                            ${listHtml}
                        </ul>
                    </div>
                `;
            }
            if(logSection) logSection.innerHTML = logHtml;
        },
        eventPage() {
            const container = document.getElementById('app-container');
            container.innerHTML = this.components.eventSection();
            this.eventListByGroup(WellTrackApp.state.activeEventGroup);
        },
        moodPage() {
            const container = document.getElementById('app-container');
            container.innerHTML = this.components.moodSection();
            WellTrackApp.data.loadTodaysState();
        },
        painPage() {
            const container = document.getElementById('app-container');
            container.innerHTML = this.components.painSection();
            document.querySelectorAll('.body-part').forEach(part => part.addEventListener('click', (e) => WellTrackApp.events.handleBodyPartClick(e)));
            WellTrackApp.data.loadTodaysState();
        },
        settingsPage() {
            const container = document.getElementById('app-container');
            container.innerHTML = this.components.settingsSection();
            const activeTab = WellTrackApp.state.activeSettingsTab;

            const tabButton = document.querySelector(`.view-toggle-btn[data-tab='${activeTab}']`);
            if (tabButton) {
                tabButton.classList.add('active');
            }

            const contentPane = document.getElementById(`settings-tab-${activeTab}`);
            if (contentPane) {
                contentPane.classList.add('active');
            }

            if (activeTab === 'eventTypes') {
                this.manageEventList();
            } else if (activeTab === 'about') {
                const versionContainer = document.getElementById('version-info-container');
                if (versionContainer) {
                    const settings = WellTrackApp.data.getSettings();
                    const lastModified = settings.welltrack_latest || document.lastModified;
                    const formattedDate = new Date(lastModified).toLocaleString('de-DE', {
                        day: '2-digit', month: '2-digit', year: 'numeric',
                        hour: '2-digit', minute: '2-digit'
                    });
                    versionContainer.innerHTML = `<p><span class="font-semibold">Benutzte Version:</span> ${formattedDate}</p>`;
                }
            }
        },
        historyPage() {
            const container = document.getElementById('app-container');
            container.innerHTML = this.components.historySection();
             // Destroy all previous charts
            Object.values(WellTrackApp.state.charts).forEach(chart => {
                if(chart && typeof chart.destroy === 'function') chart.destroy();
            });
            WellTrackApp.state.charts = {}; // Reset chart state

            this.charts.renderAll();
            WellTrackApp.events.handleHistoryTabClick(WellTrackApp.state.activeHistoryTab, false);
        },
        fullLogPage() {
            const container = document.getElementById('app-container');
            container.innerHTML = this.components.fullLogSection();

            if (!WellTrackApp.state.currentLogWeekStart) {
                WellTrackApp.state.currentLogWeekStart = WellTrackApp.utils.getStartOfWeek(new Date());
            }

            const weekStart = WellTrackApp.state.currentLogWeekStart;
            const weekEnd = dateFns.endOfWeek(weekStart, { weekStartsOn: 1 });

            const allMetrics = WellTrackApp.data.getMetrics();
            const weekMetrics = allMetrics.filter(m => {
                const metricDate = new Date(m.timestamp);
                return metricDate >= weekStart && metricDate <= weekEnd;
            });
            
            const logContainer = document.getElementById('log-entries-container');
            if (!logContainer) return;
            logContainer.innerHTML = '';
            
            if (weekMetrics.length === 0) {
                logContainer.innerHTML = '<div class="card"><p class="text-gray-500 text-center py-8">Keine Einträge in dieser Woche vorhanden.</p></div>';
            } else {
                const groupedData = {};
                weekMetrics.forEach(metric => {
                    const d = new Date(metric.timestamp);
                    const dateKey = `${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}`;
                    if (!groupedData[dateKey]) groupedData[dateKey] = [];
                    groupedData[dateKey].push(metric);
                });

                const sortedDates = Object.keys(groupedData).sort((a, b) => new Date(b) - new Date(a));

                sortedDates.forEach(dateKey => {
                    const dateObj = new Date(dateKey);
                    const weekdays = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
                    const dayName = weekdays[dateObj.getDay()];
                    const formattedDate = `${dayName} ${dateObj.getDate()}.${dateObj.getMonth() + 1}.${dateObj.getFullYear()}`;

                    const div = document.createElement('div');
                    div.className = 'py-4 border-b border-gray-200 last:border-b-0';
                    div.id = `log-day-${dateKey}`;
                    const summarizedMetrics = WellTrackApp.utils.summarizeMetrics(groupedData[dateKey]);
                    div.innerHTML = this.components.logEntry(formattedDate, summarizedMetrics);
                    logContainer.appendChild(div);
                });
            }

            // Update pagination controls
            const weekDisplay = document.getElementById('log-week-display');
            if (weekDisplay) {
                weekDisplay.textContent = WellTrackApp.utils.formatWeekRange(weekStart);
            }

            const earliestEntry = allMetrics.length > 0 ? allMetrics[0].timestamp : Date.now();
            const isLatestWeek = dateFns.isSameWeek(weekStart, new Date(), { weekStartsOn: 1 });
            const isEarliestWeek = dateFns.isSameWeek(weekStart, new Date(earliestEntry), { weekStartsOn: 1 });

            document.getElementById('log-week-next').disabled = isLatestWeek;
            document.getElementById('log-week-today').disabled = isLatestWeek;
            document.getElementById('log-week-prev').disabled = isEarliestWeek;
            document.getElementById('log-week-first').disabled = isEarliestWeek;
        },
        eventListByGroup(groupType) {
            const eventContainer = document.getElementById('todays-event-container');
            if (!eventContainer) return;

            const todaysData = WellTrackApp.data.getMetrics();
            const todaysEventsDone = todaysData.filter(e => e.metric.startsWith('event_') && WellTrackApp.utils.isToday(new Date(e.timestamp)));
            
            let allEvents = WellTrackApp.data.getEventTypes();
            let filteredEvents;

            if (groupType === '*') {
                filteredEvents = allEvents.filter(event => !event.groupType);
            } else {
                filteredEvents = allEvents.filter(event => event.groupType === groupType);
            }

            const eventItems = filteredEvents.map(event => {
                const todaysEntries = todaysEventsDone.filter(t => t.labels.activity === event.activity);
                let value = 0;
                if (event.increment === 0) {
                    value = todaysEntries.length; // For timestamp events, value is the count
                } else {
                    // After the change, there should be at most one entry for incrementing events
                    value = todaysEntries[0]?.value || 0;
                }
                return { data: event, value: value, entries: todaysEntries };
            });
            
            eventContainer.innerHTML = ''; // Clear previous items
            if(eventItems.length === 0){
                eventContainer.innerHTML = `<p class="text-center text-gray-500 py-4">Keine Ereignisse in dieser Gruppe.</p>`;
                return;
            }

            eventItems.forEach(item => {
                const div = document.createElement('div');
                div.id = `event-item-${item.data.activity}`;
                div.className = `p-4 rounded-xl flex flex-row flex-wrap items-center justify-between gap-y-2 gap-x-4 bg-gray-100`;
                if(item.data.increment === 0) {
                     div.innerHTML = WellTrackApp.render.components.eventItemTimestamp(item.data, item.value > 0, item.entries);
                } else {
                     div.innerHTML = WellTrackApp.render.components.eventItemIncrement(item.data, item.value);
                }
                eventContainer.appendChild(div);
            });
        },
        todaysLog(){
            const container = document.getElementById('todays-log-container');
            if (!container) return;

            const today = new Date();
            const yesterday = new Date();
            yesterday.setDate(today.getDate() - 1);

            const allData = WellTrackApp.data.getMetrics();
            let todaysMetrics = allData.filter(e => WellTrackApp.utils.isSameDay(new Date(e.timestamp), today));
            let yesterdaysMetrics = allData.filter(e => WellTrackApp.utils.isSameDay(new Date(e.timestamp), yesterday));
            
            // Summarize before calculating totals
            const summarizedToday = WellTrackApp.utils.summarizeMetrics(todaysMetrics);
            const summarizedYesterday = WellTrackApp.utils.summarizeMetrics(yesterdaysMetrics);

            // Calculate totals for today
            const todaysTotalPain = summarizedToday.filter(m => m.metric.startsWith('pain_')).reduce((sum, m) => sum + m.value, 0);
            const todaysTotalEvent = summarizedToday.filter(m => m.metric.startsWith('event_') && m.labels.unitType === 'min').reduce((sum, m) => sum + m.value, 0);
            const todaysTotalMood = summarizedToday.filter(m => m.metric.startsWith('mood_')).reduce((sum, m) => sum + m.value, 0);

            // Calculate totals for yesterday
            const yesterdaysTotalPain = summarizedYesterday.filter(m => m.metric.startsWith('pain_')).reduce((sum, m) => sum + m.value, 0);
            const yesterdaysTotalEvent = summarizedYesterday.filter(m => m.metric.startsWith('event_') && m.labels.unitType === 'min').reduce((sum, m) => sum + m.value, 0);
            const yesterdaysTotalMood = summarizedYesterday.filter(m => m.metric.startsWith('mood_')).reduce((sum, m) => sum + m.value, 0);

            // Generate comparison text
            const painDelta = todaysTotalPain - yesterdaysTotalPain;
            const eventDelta = todaysTotalEvent - yesterdaysTotalEvent;
            const moodDelta = todaysTotalMood - yesterdaysTotalMood;

            const renderDelta = (delta, unit = '', higherIsWorse = true) => {
                if (yesterdaysMetrics.length === 0) return `<span class="text-lg text-gray-500">...</span>`;
                if (delta === 0) return ``; // No change, show nothing
                
                const isWorse = higherIsWorse ? delta > 0 : delta < 0;
                const color = isWorse ? 'text-red-500' : 'text-green-500';
                const sign = delta > 0 ? '+' : '';
                
                return `<span class="text-sm ${color} font-semibold">${sign}${delta}${unit}</span>`;
            };

            let summaryHtml = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div onclick="WellTrackApp.events.showPage('event')" class="bg-white p-4 rounded-xl cursor-pointer hover:shadow-lg transition-shadow flex justify-between items-center">
                        <p class="text-lg font-semibold">Zeit Ereignisse</p>
                        <div class="text-right">
                           <p class="text-3xl font-bold">${todaysTotalEvent}<span class="text-base font-medium ml-1">min</span></p>
                           ${renderDelta(eventDelta, ' min', false)}
                        </div>
                    </div>
                    <div onclick="WellTrackApp.events.showPage('mood')" class="bg-white p-4 rounded-xl cursor-pointer hover:shadow-lg transition-shadow flex justify-between items-center">
                        <p class="text-lg font-semibold">Stimmung</p>
                        <div class="text-right">
                           <p class="text-3xl font-bold">${todaysTotalMood}</p>
                           ${renderDelta(moodDelta, '', false)}
                        </div>
                    </div>
                    <div onclick="WellTrackApp.events.showPage('pain')" class="bg-white p-4 rounded-xl cursor-pointer hover:shadow-lg transition-shadow flex justify-between items-center">
                        <p class="text-lg font-semibold">Schmerzen</p>
                        <div class="text-right">
                           <p class="text-3xl font-bold">${todaysTotalPain}</p>
                           ${renderDelta(painDelta, '', true)}
                        </div>
                    </div>
                </div>
            `;

            if (summarizedToday.length === 0) {
                container.innerHTML = summaryHtml + `<p class="text-gray-500 text-center py-4">Noch keine Einträge für heute.</p>`;
                return;
            }

            let listHtml = '<h3 class="text-lg font-semibold mb-2 text-gray-800">Letzte Einträge:</h3><ul class="space-y-2">';
            summarizedToday.sort((a,b) => b.timestamp - a.timestamp).forEach(metric => {
                 listHtml += `<li class="text-gray-800">${this.components.todaysLogEntry(metric)}</li>`;
            });
            listHtml += '</ul>';

            container.innerHTML = summaryHtml + listHtml;
        },
        pagination(totalItems) {
            // This function is no longer used as pagination is handled by week.
            // Kept to avoid breaking any potential calls, but it does nothing.
        },
        manageEventList() {
            const container = document.getElementById('manage-event-list');
            if (!container) return;
            container.innerHTML = '';
            WellTrackApp.data.getEventTypes().forEach((event, index) => {
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between bg-gray-100 p-3 rounded-lg';
                div.innerHTML = this.components.manageEventItem(event, index);
                container.appendChild(div);
            });
        },
        charts: {
            renderAll() {
                this.pain();
                this.event();
                this.mood();
            },
            pain() {
                const ctx = document.getElementById('painChart')?.getContext('2d');
                if (!ctx) return;
                const { dailyData, allLabels } = WellTrackApp.utils.getDailyChartData('pain_');

                // One dataset per body part for the stacked bar chart
                const datasets = allLabels.map(partName => {
                    return {
                        type: 'bar',
                        label: partName,
                        data: dailyData.map(day => ({ x: day.timestamp, y: day.values[partName] || 0 })),
                        backgroundColor: WellTrackApp.utils.generateColorFromHash(partName, 0.7),
                    };
                });

                // Line for the total cumulative pain
                datasets.push({
                    type: 'line',
                    label: 'Gesamtschmerz',
                    data: dailyData.map(day => ({ x: day.timestamp, y: day.total })),
                    borderColor: 'rgba(103, 80, 164, 1)',
                    backgroundColor: 'rgba(103, 80, 164, 0.1)',
                    borderWidth: 2,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgba(103, 80, 164, 1)',
                    fill: false,
                    tension: 0.1,
                    order: -1 // Render line on top
                });
                
                
                const yAxisOptions = {
                    stacked: true,
                    title: { display: false },
                    ticks: { ...WellTrackApp.config.CHART_FONT_OPTIONS, maxTicksLimit: 8 }
                };
                
                if (WellTrackApp.state.charts.pain) { WellTrackApp.state.charts.pain.destroy(); }
                WellTrackApp.state.charts.pain = new Chart(ctx, {
                    type: 'bar', // Default type is bar
                    data: { datasets },
                    options: {
                        maintainAspectRatio: false,
                        animation: false,
                        layout: {
                            padding: 0
                        },
                        plugins: {
                            legend: { position: 'bottom', labels: { ...WellTrackApp.config.CHART_FONT_OPTIONS } },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        scales: {
                            x: { type: 'time', time: { unit: 'day', displayFormats: { day: 'dd.MM' } }, grid: { display: false }, ticks: { ...WellTrackApp.config.CHART_FONT_OPTIONS }, stacked: true },
                            y: yAxisOptions
                        }
                    }
                });
            },
            event() {
                const eventChartContainer = document.getElementById('chart-container-event');
                if (!eventChartContainer) return;
                eventChartContainer.innerHTML = ''; // Clear previous charts

                const allEvents = WellTrackApp.data.getEventTypes();
                const displayGroups = [];
                const processedActivities = new Set();

                // 1. Identify and create cumulative groups (displayType 0)
                const cumulativeGroups = {};
                allEvents
                    .filter(e => e.displayType === 0 && e.groupType && e.unitType && e.unitType.length > 2)
                    .forEach(e => {
                        const key = `${e.groupType}|${e.unitType}`;
                        if (!cumulativeGroups[key]) {
                            cumulativeGroups[key] = {
                                isGroup: true, name: e.groupType, unit: e.unitType, activities: []
                            };
                        }
                        cumulativeGroups[key].activities.push(e.activity);
                    });

                Object.values(cumulativeGroups).forEach(group => {
                    displayGroups.push(group);
                    group.activities.forEach(act => processedActivities.add(act));
                });

                // 2. Add remaining individual events
                allEvents
                    .filter(e => !processedActivities.has(e.activity) && e.displayType !== 3)
                    .forEach(event => {
                        displayGroups.push({
                            isGroup: false, name: event.name, unit: event.unitType, activities: [event.activity]
                        });
                    });

                // 3. Render a chart for each display group
                displayGroups.forEach(group => {
                    const canvas = document.createElement('canvas');
                    const container = document.createElement('div');
                    container.style.position = 'relative';
                    container.style.height = '400px';
                    container.appendChild(canvas);
                    eventChartContainer.appendChild(container);
                    const ctx = canvas.getContext('2d');

                    const { dailyData } = WellTrackApp.utils.getDailyChartData('event_', d => group.activities.includes(d.labels.activity));

                    const chartKey = group.isGroup ? `${group.name}-${group.unit}` : group.name;
                    const yAxisLabel = group.unit ? `${group.name} (${group.unit})` : group.name;
                    const isMultiActivityGroup = group.activities.length > 1;

                    const datasets = [{
                        label: yAxisLabel,
                        data: dailyData.map(d => ({x: d.timestamp, y: d.total, details: d.details, values: d.values})),
                        borderColor: WellTrackApp.utils.generateColorFromHash(chartKey),
                        backgroundColor: WellTrackApp.utils.generateColorFromHash(chartKey, 0.5),
                        fill: true,
                        tension: 0.1,
                    }];

                    if(datasets[0].data.length > 0) {
                        const movingAverageData = WellTrackApp.utils.calculateMovingAverage(datasets[0].data, 'event_', d => group.activities.includes(d.labels.activity));
                        datasets.push({
                            label: `Durchschnitt (${group.name})`,
                            data: movingAverageData,
                            borderColor: 'rgba(239, 68, 68, 0.8)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4
                        });
                    }
                    
                    if (WellTrackApp.state.charts[chartKey]) WellTrackApp.state.charts[chartKey].destroy();
                    WellTrackApp.state.charts[chartKey] = new Chart(ctx, {
                        type: 'line', 
                        data: { datasets }, 
                        options: {
                            maintainAspectRatio: false,
                            animation: false,
                            layout: {
                                padding: 0
                            },
                            plugins: { 
                                legend: { position: 'bottom', labels: {...WellTrackApp.config.CHART_FONT_OPTIONS} },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const rawData = context.raw;
                                            let label = context.dataset.label || '';
                                            if (label) { label += ': '; }
                                            if(rawData.y) label += rawData.y;
                                            return label;
                                        },
                                        afterLabel: function(context) {
                                            const rawData = context.raw;
                                            const values = rawData.values;
                                            const lines = [];

                                            if (isMultiActivityGroup && values) {
                                                Object.entries(values).forEach(([name, value]) => {
                                                    if(value > 0) {
                                                        const eventConfig = allEvents.find(e => e.name === name);
                                                        const unit = eventConfig ? eventConfig.unitType : group.unit;
                                                        lines.push(`  - ${name}: ${value} ${unit}`);
                                                    }
                                                });
                                            }
                                            
                                            const details = rawData.details;
                                            const timestamps = Object.values(details).flat();
                                            if (timestamps.length > 0) {
                                                const times = timestamps.map(ts => new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })).join(', ');
                                                lines.push(`  Zeiten: ${times}`);
                                            }

                                            return lines;
                                        }
                                    }
                                }
                            }, 
                            scales: { 
                                x: { type: 'time', time: { unit: 'day', displayFormats: { day: 'dd.MM' } }, grid: { display: false }, ticks: {...WellTrackApp.config.CHART_FONT_OPTIONS} }, 
                                y: { title: { display: false }, ticks: {...WellTrackApp.config.CHART_FONT_OPTIONS, maxTicksLimit: 8 }, min: 0 }
                            },
                        } 
                    });
                });
            },
            mood() {
                const ctx = document.getElementById('moodChart')?.getContext('2d');
                if (!ctx) return;

                const { dailyData } = WellTrackApp.utils.getDailyChartData('mood_');
                
                const datasets = [
                    {
                        label: 'Positiv',
                        data: dailyData.map(day => ({ x: day.timestamp, y: day.positiveSum })),
                        backgroundColor: 'rgba(34, 197, 94, 0.7)', // green-500
                    },
                    {
                        label: 'Negativ',
                        data: dailyData.map(day => ({ x: day.timestamp, y: day.negativeSum })),
                        backgroundColor: 'rgba(239, 68, 68, 0.7)', // red-500
                    },
                    {
                        type: 'line',
                        label: 'Gesamtwert',
                        data: dailyData.map(day => ({ x: day.timestamp, y: day.total })),
                        borderColor: 'rgba(103, 80, 164, 1)', // primary color
                        backgroundColor: 'rgba(103, 80, 164, 0.1)',
                        borderWidth: 2,
                        pointRadius: 1,
                        pointBackgroundColor: 'rgba(103, 80, 164, 1)',
                        fill: false,
                        tension: 0.1,
                        order: -1 // Render line on top of bars
                    }
                ];

                
                const yAxisOptions = {
                    stacked: true,
                    title: { display: false },
                    ticks: { ...WellTrackApp.config.CHART_FONT_OPTIONS, maxTicksLimit: 8 }
                };
                
                if (WellTrackApp.state.charts.mood) { WellTrackApp.state.charts.mood.destroy(); }
                WellTrackApp.state.charts.mood = new Chart(ctx, {
                    type: 'bar',
                    data: { datasets },
                    options: {
                        maintainAspectRatio: false,
                        animation: false,
                        layout: {
                            padding: 0
                        },
                        plugins: { 
                            legend: { position: 'bottom', labels: { ...WellTrackApp.config.CHART_FONT_OPTIONS } },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y;
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { type: 'time', time: { unit: 'day', displayFormats: { day: 'dd.MM' } }, grid: { display: false }, ticks: { ...WellTrackApp.config.CHART_FONT_OPTIONS }, stacked: true },
                            y: yAxisOptions
                        }
                    }
                });
            }
        },
        modal: {
            show(content, options = {}) {
                const modalContent = document.getElementById('modal-content');
                // Reset to default classes, except for the base ones
                modalContent.className = 'bg-white rounded-3xl p-6 shadow-xl w-full max-h-[90vh] overflow-y-auto';
                const modalClass = options.modalClass || 'max-w-md';
                modalContent.classList.add(...modalClass.split(' '));

                modalContent.innerHTML = content;
                document.getElementById('modal-container').classList.remove('hidden');
            },
            hide() {
                document.getElementById('modal-container').classList.add('hidden');
                document.getElementById('modal-content').innerHTML = '';
                WellTrackApp.state.currentEditingEvent = null;
            },
            showPainSelector(part, view) {
                WellTrackApp.state.currentPainPart = part;
                const viewName = view === 'front' ? 'Vorderseite' : 'Rückseite';
                const content = WellTrackApp.render.components.painModalContent(part.dataset.name, viewName);
                this.show(content);

                const handleKeyPress = (e) => {
                    if (e.key === 'Escape') {
                        this.hide();
                        window.removeEventListener('keydown', handleKeyPress);
                        return;
                    }
                    const keyMap = {
                        '-': 0, 'l': 1, 'u': 2, 's': 3, 'f': 4, 'x': 5
                    };
                    const level = keyMap[e.key.toLowerCase()];
                    if (level !== undefined) {
                        WellTrackApp.events.handleSetPainLevel(level);
                        window.removeEventListener('keydown', handleKeyPress);
                    }
                };
                window.addEventListener('keydown', handleKeyPress);
            },
            showAlert(title, message) {
                const content = `<h3 class="text-xl font-medium mb-4">${title}</h3><p class="mb-6">${message}</p><div class="flex justify-end"><button onclick="WellTrackApp.render.modal.hide()" class="btn btn-primary">OK</button></div>`;
                this.show(content);
            },
            showConfirmation(title, message, onConfirm, options = {}) {
                const {
                    confirmText = 'Bestätigen',
                    abortText = 'Abbrechen',
                    modalClass = 'max-w-md',
                    confirmButtonClass = 'btn-error-primary'
                } = options;
                const content = `<h3 class="text-xl font-medium mb-4">${title}</h3><p class="mb-6">${message}</p><div class="flex justify-end gap-4"><button onclick="WellTrackApp.render.modal.hide()" class="btn btn-tertiary">${abortText}</button><button id="confirm-action-btn" class="btn ${confirmButtonClass}">${confirmText}</button></div>`;
                this.show(content, { modalClass });
                document.getElementById('confirm-action-btn').onclick = () => { onConfirm(); this.hide(); };
            }
        },
        components: {
            todaySection: () => {
                const today = new Date();
                const weekdays = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
                const dayName = weekdays[today.getDay()];
                const dateString = `${dayName} ${today.getDate()}.${today.getMonth() + 1}.${today.getFullYear()}`;
                return `
                <div class="flex justify-between items-center pt-2 px-2 mb-4">
                    <h2 class="h2-style">Heute</h2>
                    <span class="text-lg text-gray-800">${dateString}</span>
                </div>
                <div id="today-summary-cards" class="grid grid-cols-2 gap-4 mb-6">
                    <!-- Mood and Pain cards will be rendered here -->
                </div>
                <div id="today-event-groups" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mb-6">
                    <!-- Event group cards will be rendered here -->
                </div>
                <div id="todays-log-section" class="mb-6">
                    <!-- Collapsible log will be rendered here by todayPage() -->
                </div>
                `;
            },
            eventSection: () => {
                const events = WellTrackApp.data.getEventTypes();
                const hasNoGroup = events.some(e => !e.groupType);
                const groups = [...new Set(events.map(e => e.groupType).filter(g => g))].sort();
                if (hasNoGroup) { groups.push('*'); }

                // If no group is selected, default to the first one available
                if (WellTrackApp.state.activeEventGroup === null && groups.length > 0) {
                    WellTrackApp.state.activeEventGroup = groups[0];
                }

                let groupButtons = groups.map((group) => {
                    const groupName = group === '*' ? 'Allgemein' : group;
                    const activeClass = WellTrackApp.state.activeEventGroup === group ? 'active' : '';
                    return `<button type="button" onclick="WellTrackApp.events.handleEventGroupToggle('${group}')" id="btn-event-group-${group}" class="view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full ${activeClass}">${groupName}</button>`
                }).join('');

                return `
                <div class="card pt-2">
                    <div class="flex md:flex-row md:justify-between md:items-center gap-3 mb-2">
                        <h2 class="h2-style flex-shrink-0">Ereignisse</h2>
                        <div class="submenu-container" role="group">
                            ${groupButtons}
                        </div>
                    </div>
                    <div id="todays-event-container" class="space-y-2"></div>
                </div>`;
            },
            moodSection: () => {
                const moodGroups = WellTrackApp.config.MOOD_GROUPS;
                const activeGroupKey = WellTrackApp.state.activeMoodGroup;
                const activeGroup = moodGroups[activeGroupKey];
                 let groupButtons = Object.keys(moodGroups).map(groupId =>
                    `<button type="button" onclick="WellTrackApp.events.handleMoodGroupToggle('${groupId}')" id="btn-mood-${groupId}" class="view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full ${activeGroupKey === groupId ? 'active' : ''}">${moodGroups[groupId].name}</button>`
                ).join('');

                return `
                <div class="card pt-2">
                     <div class="flex flex-col md:flex-row md:justify-between md:items-center gap-3 mb-6">
                        <h2 id="mood-section-title" class="h2-style flex-shrink-0">Stimmung</h2>
                        <div class="submenu-container" role="group">
                            ${groupButtons}
                        </div>
                    </div>
                    <div id="mood-container" class="space-y-4">${activeGroup.questions.map(q => WellTrackApp.render.components.moodSlider(q)).join('')}</div>
                </div>`;
            },
            painSection: () => {
                const currentView = WellTrackApp.state.currentPainView;
                return `
                <div class="card pt-2">
                    <div class="flex md:flex-row md:justify-between md:items-center gap-3">
                        <h2 id="pain-section-title" class="h2-style flex-shrink-0">Schmerzen</h2>
                        <div class="submenu-container" role="group">
                            <button type="button" onclick="WellTrackApp.events.handleViewToggle('front')" id="btn-view-front" class="view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 rounded-full hover:bg-gray-100 ${currentView === 'front' ? 'active' : ''}">Vorderseite</button>
                            <button type="button" onclick="WellTrackApp.events.handleViewToggle('back')" id="btn-view-back" class="view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 rounded-full hover:bg-gray-100 ${currentView === 'back' ? 'active' : ''}">Rückseite</button>
                        </div>
                    </div>
                    <div class="flex justify-center">
                        <svg width="400" height="650" viewBox="0 0 400 650">
                            <g id="body-front" class="${currentView === 'front' ? '' : 'hidden'}">
                                <circle   id="front_head"          data-name="Kopf" class="body-part" cx="200" cy="50" r="45"><title>Kopf</title></circle>
                                <rect     id="front_neck"          data-name="Hals" class="body-part" x="180" y="99" width="40" height="45" rx="10"><title>Hals</title></rect>
                                <rect     id="front_shoulder_left" data-name="Schulter (L)" class="body-part" x="55" y="99" width="121" height="45" rx="10"><title>Schulter (L)</title></rect>
                                <rect     id="front_shoulder_right"data-name="Schulter (R)" class="body-part" x="224" y="99" width="121" height="45" rx="10"><title>Schulter (R)</title></rect>
                                <rect     id="front_chest"         data-name="Brust" class="body-part" x="125" y="148" width="150" height="80" rx="10"><title>Brust</title></rect>
                                <rect     id="front_abdomen"       data-name="Bauch" class="body-part" x="128" y="232" width="144" height="60" rx="10"><title>Bauch</title></rect>
                                <rect     id="front_pelvis_left"   data-name="Becken (L)" class="body-part" x="128" y="296" width="62" height="60" rx="10"><title>Becken (L)</title></rect>
                                <rect     id="front_pelvis_right"  data-name="Becken (R)" class="body-part" x="210" y="296" width="62" height="60" rx="10"><title>Becken (R)</title></rect>
                                <rect     id="front_groin"         data-name="Leiste" class="body-part" x="190" y="326" width="20" height="40" rx="10"><title>Leiste</title></rect>
                                <rect     id="front_upper_arm_left" data-name="Oberarm (L)" class="body-part" x="51" y="148" width="41" height="100" rx="10"><title>Oberarm (L)</title></rect>
                                <rect     id="front_lower_arm_left" data-name="Unterarm (L)" class="body-part" x="51" y="252" width="41" height="90" rx="10"><title>Unterarm (L)</title></rect>
                                <rect     id="front_hand_left"     data-name="Hand (L)" class="body-part" x="47" y="346" width="50" height="50" rx="10"><title>Hand (L)</title></rect>
                                <rect     id="front_upper_arm_right" data-name="Oberarm (R)" class="body-part" x="308" y="148" width="41" height="100" rx="10"><title>Oberarm (R)</title></rect>
                                <rect     id="front_lower_arm_right" data-name="Unterarm (R)" class="body-part" x="308" y="252" width="41" height="90" rx="10"><title>Unterarm (R)</title></rect>
                                <rect     id="front_hand_right"    data-name="Hand (R)" class="body-part" x="304" y="346" width="50" height="50" rx="10"><title>Hand (R)</title></rect>
                                <rect     id="front_upper_leg_left" data-name="Oberschenkel (L)" class="body-part" x="133" y="360" width="41" height="120" rx="10"><title>Oberschenkel (L)</title></rect>
                                <rect     id="front_lower_leg_left" data-name="Unterschenkel (L)" class="body-part" x="133" y="484" width="41" height="110" rx="10"><title>Unterschenkel (L)</title></rect>
                                <rect     id="front_upper_leg_right" data-name="Oberschenkel (R)" class="body-part" x="227" y="360" width="41" height="120" rx="10"><title>Oberschenkel (R)</title></rect>
                                <rect     id="front_lower_leg_right" data-name="Unterschenkel (R)" class="body-part" x="227" y="484" width="41" height="110" rx="10"><title>Unterschenkel (R)</title></rect>
                                <rect     id="front_foot_left"     data-name="Fuß (L)" class="body-part" x="128" y="598" width="50" height="40" rx="10"><title>Fuß (L)</title></rect>
                                <rect     id="front_foot_right"    data-name="Fuß (R)" class="body-part" x="222" y="598" width="50" height="40" rx="10"><title>Fuß (R)</title></rect>
                                <g class="pain-free-btn" onclick="WellTrackApp.events.handlePainFreeClick()" style="cursor: pointer;">
                                    <circle cx="350" cy="50" r="25" fill="var(--md-sys-color-surface-container-highest)" stroke="var(--md-sys-color-outline)" stroke-width="0.5"></circle>
                                    <text x="350" y="45" class="svg-label" text-anchor="middle">
                                        <tspan x="350" dy="0em">Schmerz</tspan>
                                        <tspan x="350" dy="1.2em">Frei</tspan>
                                    </text>
                                    <title>Schmerz Frei</title>
                                </g>
                            </g>
                            <g id="body-back" class="${currentView === 'back' ? '' : 'hidden'}">
                                <circle   id="back_head"           data-name="Hinterkopf" class="body-part" cx="200" cy="50" r="45"><title>Hinterkopf</title></circle>
                                <rect     id="back_neck"           data-name="Nacken" class="body-part" x="180" y="99" width="40" height="45" rx="10"><title>Nacken</title></rect><text class="label" x="200" y="121.5">HWS</text>
                                <rect     id="back_shoulder_left"  data-name="Schulter (L, h)" class="body-part" x="55" y="99" width="121" height="45" rx="10"><title>Schulter (L, h)</title></rect>
                                <rect     id="back_shoulder_right" data-name="Schulter (R, h)" class="body-part" x="224" y="99" width="121" height="45" rx="10"><title>Schulter (R, h)</title></rect>
                                <rect     id="back_upper_back_left" data-name="Oberer Rücken (L)" class="body-part" x="125" y="148" width="56.25" height="80" rx="10"><title>Oberer Rücken (L)</title></rect>
                                <rect     id="back_upper_back_middle" data-name="Obere Wirbelsäule" class="body-part" x="181.25" y="148" width="37.5" height="80" rx="10"><title>Obere Wirbelsäule</title></rect><text class="label" x="200" y="188">BWS</text>
                                <rect     id="back_upper_back_right" data-name="Oberer Rücken (R)" class="body-part" x="218.75" y="148" width="56.25" height="80" rx="10"><title>Oberer Rücken (R)</title></rect>
                                <rect     id="back_lower_back_left" data-name="Unterer Rücken (L)" class="body-part" x="128" y="232" width="54" height="60" rx="10"><title>Unterer Rücken (L)</title></rect>
                                <rect     id="back_lower_back_middle" data-name="Untere Wirbelsäule" class="body-part" x="182" y="232" width="36" height="124" rx="10"><title>Untere Wirbelsäule</title></rect><text class="label" x="200" y="294">LWS</text>
                                <rect     id="back_lower_back_right" data-name="Unterer Rücken (R)" class="body-part" x="218" y="232" width="54" height="60" rx="10"><title>Unterer Rücken (R)</title></rect>
                                <rect     id="back_glute_left"     data-name="Gesäß (L)" class="body-part" x="128" y="296" width="50" height="60" rx="10"><title>Gesäß (L)</title></rect>
                                <rect     id="back_glute_right"    data-name="Gesäß (R)" class="body-part" x="222" y="296" width="50" height="60" rx="10"><title>Gesäß (R)</title></rect>
                                <rect     id="back_upper_arm_left" data-name="Oberarm (L, h)" class="body-part" x="51" y="148" width="41" height="100" rx="10"><title>Oberarm (L, h)</title></rect>
                                <rect     id="back_lower_arm_left" data-name="Unterarm (L, h)" class="body-part" x="51" y="252" width="41" height="90" rx="10"><title>Unterarm (L, h)</title></rect>
                                <rect     id="back_hand_left"      data-name="Hand (L, h)" class="body-part" x="47" y="346" width="50" height="50" rx="10"><title>Hand (L, h)</title></rect>
                                <rect     id="back_upper_arm_right" data-name="Oberarm (R, h)" class="body-part" x="308" y="148" width="41" height="100" rx="10"><title>Oberarm (R, h)</title></rect>
                                <rect     id="back_lower_arm_right" data-name="Unterarm (R, h)" class="body-part" x="308" y="252" width="41" height="90" rx="10"><title>Unterarm (R, h)</title></rect>
                                <rect     id="back_hand_right"     data-name="Hand (R, h)" class="body-part" x="304" y="346" width="50" height="50" rx="10"><title>Hand (R, h)</title></rect>
                                <rect     id="back_upper_leg_left" data-name="Oberschenkel (L, h)" class="body-part" x="133" y="360" width="41" height="120" rx="10"><title>Oberschenkel (L, h)</title></rect>
                                <rect     id="back_lower_leg_left" data-name="Unterschenkel (L, h)" class="body-part" x="133" y="484" width="41" height="110" rx="10"><title>Unterschenkel (L, h)</title></rect>
                                <rect     id="back_upper_leg_right" data-name="Oberschenkel (R, h)" class="body-part" x="227" y="360" width="41" height="120" rx="10"><title>Oberschenkel (R, h)</title></rect>
                                <rect     id="back_lower_leg_right" data-name="Unterschenkel (R, h)" class="body-part" x="227" y="484" width="41" height="110" rx="10"><title>Unterschenkel (R, h)</title></rect>
                                <rect     id="back_foot_left"      data-name="Fuß (L, h)" class="body-part" x="128" y="598" width="50" height="40" rx="10"><title>Fuß (L, h)</title></rect>
                                <rect     id="back_foot_right"     data-name="Fuß (R, h)" class="body-part" x="222" y="598" width="50" height="40" rx="10"><title>Fuß (R, h)</title></rect>
                                <g class="pain-free-btn" onclick="WellTrackApp.events.handlePainFreeClick()" style="cursor: pointer;">
                                    <circle cx="350" cy="50" r="25" fill="var(--md-sys-color-surface-container-highest)" stroke="var(--md-sys-color-outline)" stroke-width="0.5"></circle>
                                    <text x="350" y="45" class="svg-label" text-anchor="middle">
                                        <tspan x="350" dy="0em">Schmerz</tspan>
                                        <tspan x="350" dy="1.2em">Frei</tspan>
                                    </text>
                                    <title>Schmerz Frei</title>
                                </g>
                            </g>
                        </svg>
                    </div>
                </div>`;
            },
            historySection: () => {
                const activeTab = WellTrackApp.state.activeHistoryTab;
                return `
                <div class="container mx-auto max-w-4xl">
                    <div class="card pt-2 mb-6">
                        <div class="flex md:flex-row md:justify-end items-center gap-3">
                            <div class="flex items-start gap-2">
                                <h2 id="log-title" class="h2-style flex-shrink-0">Verlauf</h2>
                                <select id="time-range-selector" onchange="WellTrackApp.events.handleTimeRangeChange(event)" class="border border-gray-300 rounded-full text-sm focus:ring-blue-500 focus:border-blue-500 block w-auto p-2.5">
                                    <option value="7" ${WellTrackApp.state.timeRange === 7 ? 'selected' : ''}>Letzte 7 Tage</option>
                                    <option value="30" ${WellTrackApp.state.timeRange === 30 ? 'selected' : ''}>Letzte 30 Tage</option>
                                    <option value="90" ${WellTrackApp.state.timeRange === 90 ? 'selected' : ''}>Letzte 3 Monate</option>
                                </select>
                            </div>
                        <div id="history-tabs" class="submenu-container" role="group">
                                <button onclick="WellTrackApp.events.handleHistoryTabClick('event')" class="history-tab view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full" data-tab="event">Ereignisse</button>
                                <button onclick="WellTrackApp.events.handleHistoryTabClick('mood')" class="history-tab view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full" data-tab="mood">Stimmung</button>
                                <button onclick="WellTrackApp.events.handleHistoryTabClick('pain')" class="history-tab view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full" data-tab="pain">Schmerz</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="w-full">
                    <div id="chart-container-event" class="chart-container space-y-4"></div>
                    <div id="chart-container-mood" class="chart-container hidden" style="position: relative; height: 700px;"><canvas id="moodChart"></canvas></div>
                    <div id="chart-container-pain" class="chart-container hidden" style="position: relative; height: 700px;"><canvas id="painChart"></canvas></div>
                </div>`;
            },
            fullLogSection: () => `
                <div class="flex flex-nowrap justify-between items-center gap-4 mb-2">
                    <h2 class="h2-style">Protokoll</h2>
                    <div id="log-pagination" class="flex items-center justify-end gap-1 bg-gray-100 p-1 rounded-full">
                        <button id="log-week-first" onclick="WellTrackApp.events.handleWeekChange('first')" class="btn btn-secondary !rounded-full !p-2" title="Erste Woche">
                            <span class="material-symbols-outlined">keyboard_double_arrow_left</span>
                        </button>
                        <button id="log-week-prev" onclick="WellTrackApp.events.handleWeekChange('prev')" class="btn btn-secondary !rounded-full !p-2" title="Woche zurück">
                            <span class="material-symbols-outlined">chevron_left</span>
                        </button>
                        <span id="log-week-display" class="tabular-nums font-semibold text-gray-700 px-3"></span>
                        <button id="log-week-next" onclick="WellTrackApp.events.handleWeekChange('next')" class="btn btn-secondary !rounded-full !p-2" title="Woche vor">
                            <span class="material-symbols-outlined">chevron_right</span>
                        </button>
                        <button id="log-week-today" onclick="WellTrackApp.events.handleWeekChange('today')" class="btn btn-secondary !rounded-full !p-2" title="Heutige Woche">
                            <span class="material-symbols-outlined">today</span>
                        </button>
                    </div>
                </div>
                <div id="log-entries-container" class="card"></div>
            `,
            settingsSection: () => {
                const settings = WellTrackApp.data.getSettings();
                const perm = WellTrackApp.state.notificationPermission;

                let reminderContentHtml = '';
                if (perm === 'denied') {
                    reminderContentHtml = '<p class="text-red-600">Sie müssen die Berechtigung in den Browser-Einstellungen ändern, um Benachrichtigungen zu erhalten.</p>';
                } else if (perm === 'default') {
                    reminderContentHtml = '<button onclick="WellTrackApp.events.requestNotificationPermission()" class="btn btn-secondary w-full">Browser-Benachrichtigungen erlauben</button>';
                } else { // perm === 'granted'
                    if (settings.reminders_active) {
                        reminderContentHtml = `
                            <p class="text-gray-600">Status: <span class="font-bold text-green-600">Aktiviert</span></p>
                            <div>
                                <label for="reminder-times" class="block mb-1 font-medium text-gray-900">Erinnerungen um:</label>
                                <input type="text" id="reminder-times" value="${settings.reminderTimes}" onchange="WellTrackApp.events.saveReminderTimes(this.value)" class="w-full p-2 border border-gray-300 rounded-lg" placeholder="12:00, 17:00, 23:30">
                                <p class="text-xs text-gray-500 mt-1">Format: hh:mm[,hh:mm]*</p>
                            </div>
                            <div class="flex gap-4">
                                <button onclick="WellTrackApp.events.handleDeactivateReminders()" class="btn btn-tertiary flex-1">Deaktivieren</button>
                                <button onclick="WellTrackApp.events.showTestNotification()" class="btn btn-secondary flex-1">Test Nachricht</button>
                            </div>
                        `;
                    } else {
                        reminderContentHtml = `
                            <p class="text-gray-600">Status: <span class="font-bold">Nicht aktiviert</span></p>
                            <button onclick="WellTrackApp.events.handleActivateReminders()" class="btn btn-secondary w-full">Erinnerungen aktivieren</button>
                        `;
                    }
                }

                return `
                <div class="card pt-2">
                     <div class="flex md:flex-row md:justify-between md:items-center gap-3 mb-4">
                        <h2 class="h2-style flex-shrink-0">Einstellungen</h2>
                        <div class="submenu-container" role="group">
                            <button onclick="WellTrackApp.events.handleSettingsTabClick('about')" class="view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full" data-tab="about">Über</button>
                            <button onclick="WellTrackApp.events.handleSettingsTabClick('reminders')" class="view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full" data-tab="reminders">Erinnerungen</button>
                            <button onclick="WellTrackApp.events.handleSettingsTabClick('data')" class="view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full" data-tab="data">Import/Export</button>
                            <button onclick="WellTrackApp.events.handleSettingsTabClick('eventTypes')" class="view-toggle-btn px-4 py-2 text-sm font-medium bg-white border border-gray-200 hover:bg-gray-100 rounded-full" data-tab="eventTypes">Ereignisarten</button>
                        </div>
                    </div>

                    <div id="settings-tab-eventTypes" class="settings-tab-content">
                        <div id="manage-event-list" class="space-y-2 mb-4"></div>
                        <div class="mt-4"><button id="add-new-event-btn" onclick="WellTrackApp.events.handleShowEventTypeForm()" class="btn btn-secondary w-full"><span class="material-symbols-outlined mr-2">add</span>Neue hinzufügen</button></div>
                    </div>
                    <div id="settings-tab-data" class="settings-tab-content">
                        <p class="text-gray-800 mb-4">Sie können Ihre Daten als JSON-Datei exportieren oder eine zuvor exportierte Datei wieder importieren.</p>
                        <div class="flex flex-col md:flex-row gap-4">
                            <button onclick="WellTrackApp.data.exportData()" class="btn btn-secondary flex-1"><span class="material-symbols-outlined mr-2">download</span> Daten exportieren</button>
                            <label class="btn btn-error flex-1 cursor-pointer"><span class="material-symbols-outlined mr-2">upload</span><span>Daten importieren</span><input type="file" id="import-file" class="hidden" accept=".json" onchange="WellTrackApp.data.importData(event)"></label>
                            <button onclick="WellTrackApp.events.handleDeleteAllData()" class="btn btn-error flex-1"><span class="material-symbols-outlined mr-2">delete_forever</span> Alle Daten löschen</button>
                        </div>
                    </div>
                    <div id="settings-tab-reminders" class="settings-tab-content">
                        <div id="reminder-section" class="space-y-4">
                            ${reminderContentHtml}
                        </div>
                    </div>
                    <div id="settings-tab-about" class="settings-tab-content">
                        <div class="text-base text-gray-800 space-y-6 p-4">
                            <p class="text-lg">WellTrack ist ein persönliches und 100% privates Gesundheitstagebuch. Alle Daten bleiben ausschließlich auf dem eigenen Gerät.</p>
                            <div>
                                <h4 class="text-lg font-semibold mb-2">Ressourcen</h4>
                                <ul class="list-disc list-inside space-y-2">
                                    <li><a href="https://wuxxin.github.io/welltrack/" target="_blank" class="text-blue-600 hover:underline">Homepage & Dokumentation</a></li>
                                    <li><a href="https://github.com/wuxxin/welltrack" target="_blank" class="text-blue-600 hover:underline">Quellcode auf GitHub</a></li>
                                    <li><a href="https://github.com/wuxxin/welltrack/blob/main/LICENSE" target="_blank" class="text-blue-600 hover:underline">Lizenz (BSD 3-Clause License)</a></li>
                                </ul>
                            </div>
                            <div id="version-info-container" class="pt-6 mt-6 border-t border-gray-300">
                                <!-- Version info will be injected here -->
                            </div>
                        </div>
                    </div>
                </div>
                `;
            },
            eventItemIncrement: (event, value) => `
                <span class="text-base sm:text-lg font-medium text-gray-800 flex-1">${event.name}</span>
                <div class="flex items-center gap-2">
                    <button onclick="WellTrackApp.events.handleEventIncrement('${event.activity}', -${event.increment})" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold h-10 w-10 rounded-full flex items-center justify-center flex-shrink-0">
                        <span class="material-symbols-outlined">remove</span>
                    </button>
                    <span id="value-${event.activity}" class="tabular-nums text-xl sm:text-2xl font-semibold w-20 sm:w-24 text-center">${value} ${event.unitType}</span>
                    <button onclick="WellTrackApp.events.handleEventIncrement('${event.activity}', ${event.increment})" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold h-10 w-10 rounded-full flex items-center justify-center flex-shrink-0">
                        <span class="material-symbols-outlined">add</span>
                    </button>
                </div>`,
            eventItemTimestamp: (event, isDoneToday, entries) => {
                const count = entries.length;
                const lastEntry = count > 0 ? entries.sort((a, b) => b.timestamp - a.timestamp)[0] : null;

                let lastTimestampInfo = '';
                if (lastEntry) {
                    const time = new Date(lastEntry.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    lastTimestampInfo = `(${count}x, zuletzt um ${time})`;
                }


                let buttonsHtml = '';
                if (isDoneToday) {
                    // State B: Logged for today. Show Undo and Again buttons.
                    buttonsHtml = `
                        <button onclick="WellTrackApp.events.handleUndoTimestamp('${event.activity}')" class="btn btn-tertiary btn-sm">
                            <span class="material-symbols-outlined mr-1 sm:mr-2">undo</span>Rückgängig
                        </button>
                        <button onclick="WellTrackApp.events.handleTimestampEvent('${event.activity}')" class="btn btn-secondary btn-sm">
                            <span class="material-symbols-outlined mr-1 sm:mr-2">refresh</span>Erneut/e ${event.unitType || 'Einnahme'}
                        </button>
                    `;
                } else {
                    // State A: Not logged for today. Show initial button.
                    const buttonText = event.unitType || 'Einnahme';
                    buttonsHtml = `
                        <button onclick="WellTrackApp.events.handleTimestampEvent('${event.activity}')" class="btn btn-secondary btn-sm sm:btn-md min-w-[120px] sm:min-w-[150px]">
                            <span class="material-symbols-outlined mr-1 sm:mr-2">add</span>${buttonText}
                        </button>
                    `;
                }

                return `
                    <div class="flex items-baseline">
                         <span class="text-base sm:text-lg font-medium text-gray-800">${event.name}</span>
                         <span class="text-sm sm:text-sm text-gray-800 font-normal ml-2">${lastTimestampInfo}</span>
                    </div>
                    <div class="flex items-center gap-2 ml-auto">
                        ${buttonsHtml}
                    </div>
                `;
            },
            todaysLogEntry: (metric) => {
                const time = new Date(metric.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                if (metric.metric === 'pain_free_level') {
                    return `(${time}) Status: <span class="font-bold px-2 py-1 rounded" style="background-color:#86efac;">Schmerz Frei</span>`;
                }
                if (metric.metric.startsWith('pain_')) {
                    const level = metric.value;
                    const props = WellTrackApp.config.PAIN_LEVELS[level] || {};
                    const color = props.color || '#ccc';
                    const textColor = (level > 2 && level < 6) ? 'white' : 'black';
                    return `(${time}) Schmerz in ${metric.labels.name}: <span class="font-bold px-2 py-1 rounded" style="background-color:${color}; color: ${textColor};">Stufe ${level}</span>`;
                }
                if (metric.metric.startsWith('event_')) {
                     if (metric.metric.endsWith('_timestamp')) {
                        return `(${time}) Ereignis ${metric.labels.name}: <span class="font-bold">Erfasst</span>`;
                     }
                    return `(${time}) Ereignis ${metric.labels.name}: <span class="font-bold">${metric.value} ${metric.labels.unitType || ''}</span>`;
                }
                if (metric.metric.startsWith('mood_')) {
                    const colorClass = metric.value > 0 ? 'text-green-600' : 'text-red-600';
                    return `(${time}) Stimmung ${metric.labels.name}: <span class="font-bold ${colorClass}">${metric.value > 0 ? '+' : ''}${metric.value}</span>`;
                }
                return `(${time}) Unbekannter Eintrag`;
            },
            logEntry: (formattedDate, metrics) => {
                // Sort events by time (newest first)
                const eventMetrics = metrics.filter(m => m.metric.startsWith('event_')).sort((a, b) => b.timestamp - a.timestamp);
                let eventsHtml = '';
                if (eventMetrics.length > 0) {
                    const eventsByGroup = eventMetrics.reduce((acc, t) => {
                        const group = t.labels.groupType || 'Ohne Gruppe';
                        if (!acc[group]) acc[group] = [];
                        acc[group].push(t);
                        return acc;
                    }, {});

                    eventsHtml = Object.entries(eventsByGroup).map(([group, entries]) => {
                        const entryDetails = entries.map(t => {
                            const time = new Date(t.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            if (t.metric.endsWith('_timestamp')) {
                                return `<div class="ml-4 text-gray-700 text-base"><span class="font-semibold">Um ${time}</span>: ${t.labels.name}</div>`;
                            } else {
                                const valueHtml = `<span class="font-semibold">${t.value} ${t.labels.unitType || ''}</span>`;
                                return `<div class="ml-4 text-gray-700 text-base">${t.labels.name}: ${valueHtml}</div>`;
                            }
                        }).join('');
                        return `<div class="mt-2"><h5 class="font-semibold text-lg">${group}</h5>${entryDetails}</div>`;
                    }).join('');
                }

                // --- Mood Slots (newest first) ---
                const moodMetrics = metrics.filter(m => m.metric.startsWith('mood_')).sort((a, b) => a.timestamp - b.timestamp);
                let moodHtml = '';
                if (moodMetrics.length > 0) {
                    const moodSlots = [];
                    let currentSlot = [];
                    // Iterate from oldest to newest to create slots
                    [...moodMetrics].reverse().forEach((metric, index, arr) => {
                        if (index > 0 && (metric.timestamp - arr[index-1].timestamp > 600000)) {
                            moodSlots.push(currentSlot);
                            currentSlot = [];
                        }
                        currentSlot.push(metric);
                    });
                    moodSlots.push(currentSlot);

                    // Render slots newest first
                    moodHtml = moodSlots.reverse().map(group => {
                        if (group.length === 0) return '';
                        const firstEntryTime = new Date(group[0].timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        const totalScore = group.reduce((sum, m) => sum + m.value, 0);
                        const totalColorClass = totalScore > 0 ? 'text-green-600' : (totalScore < 0 ? 'text-red-600' : 'text-gray-600');
                        const totalSign = totalScore > 0 ? '+' : '';

                        const detailsMatrix = group.map(m => {
                            const valueColorClass = m.value > 0 ? 'text-green-600' : 'text-red-600';
                            return `<div class="flex justify-between items-center p-2 rounded-lg bg-gray-50"><span class="text-gray-800">${m.labels.name}</span><span class="font-bold text-lg ${valueColorClass}">${m.value > 0 ? '+' : ''}${m.value}</span></div>`;
                        }).join('');

                        return `<div class="mt-2"><h5 class="font-semibold text-lg">Um ${firstEntryTime}: <span class="font-normal text-gray-600"> Gesamt: <span class="font-bold ${totalColorClass}">${totalSign}${totalScore}</span></span></h5><div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2 mt-2">${detailsMatrix}</div></div>`;
                    }).join('');
                }

                // --- Pain Slots (newest first) ---
                const painMetrics = metrics.filter(m => m.metric.startsWith('pain_')).sort((a, b) => a.timestamp - b.timestamp);
                let painHtml = '';
                if (painMetrics.length > 0) {
                    const painSlots = [];
                    let currentSlot = [];
                     // Iterate from oldest to newest to create slots
                    [...painMetrics].reverse().forEach((metric, index, arr) => {
                        if (index > 0 && (metric.timestamp - arr[index-1].timestamp > 600000)) {
                            painSlots.push(currentSlot);
                            currentSlot = [];
                        }
                        currentSlot.push(metric);
                    });
                    painSlots.push(currentSlot);

                    // Render slots newest first
                    painHtml = painSlots.reverse().map(group => {
                        if (group.length === 0) return '';
                        const firstEntryTime = new Date(group[0].timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        const totalScore = group.reduce((sum, m) => sum + m.value, 0);
                        const totalColor = totalScore > 0 ? 'text-red-600' : 'text-gray-600';

                        const detailsMatrix = group.map(p => {
                            if (p.metric === 'pain_free_level') return `<div class="p-2 rounded-lg flex justify-center items-center font-semibold" style="background-color: #86efac">Schmerz Frei</div>`;
                            const props = WellTrackApp.config.PAIN_LEVELS[p.value] || {};
                            const textColor = (p.value > 2 && p.value < 6) ? 'text-white' : 'text-black';
                            return `<div class="p-2 rounded-lg flex justify-between items-center" style="background-color: ${props.color || '#ccc'}"><span class="${textColor}">${p.labels.name}</span><span class="font-bold text-lg ${textColor}">${p.value}</span></div>`;
                        }).join('');

                        return `<div class="mt-2"><h5 class="font-semibold text-lg">Um ${firstEntryTime}: <span class="font-normal text-gray-600">Gesamt: <span class="font-bold ${totalColor}">${totalScore}</span></span></h5><div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2 mt-2">${detailsMatrix}</div></div>`;
                    }).join('');
                }

                let html = '';
                if (eventsHtml) {
                    html += `<div><div class="flex justify-between items-baseline"><h4 class="font-semibold text-lg mb-2 text-gray-800">Ereignisse</h4><h3 class="font-bold text-lg text-gray-600">${formattedDate}</h3></div><div class="pl-4">${eventsHtml}</div></div>`;
                    if (moodHtml) html += `<div class="mt-4 pt-4 border-t border-gray-200"><h4 class="font-semibold text-lg mb-2 text-gray-800">Stimmung</h4><div class="pl-4">${moodHtml}</div></div>`;
                    if (painHtml) html += `<div class="mt-4 pt-4 border-t border-gray-200"><h4 class="font-semibold text-lg mb-2 text-gray-800">Schmerz</h4><div class="pl-4">${painHtml}</div></div>`;
                } else {
                    html += `<div class="flex justify-end mb-2"><h3 class="font-bold text-lg text-gray-600">${formattedDate}</h3></div>`;
                    let isFirstSection = true;
                    if (moodHtml) {
                        html += `<div><h4 class="font-semibold text-lg mb-2 text-gray-800">Stimmung</h4><div class="pl-4">${moodHtml}</div></div>`;
                        isFirstSection = false;
                    }
                    if (painHtml) {
                        const dividerClass = isFirstSection ? '' : 'mt-4 pt-4 border-t border-gray-200';
                        html += `<div class="${dividerClass}"><h4 class="font-semibold text-lg mb-2 text-gray-800">Schmerz</h4><div class="pl-4">${painHtml}</div></div>`;
                    }
                }
                return html;
            },
            paginationControls: (currentPage, totalPages) => { /* No longer used */ },
            manageEventItem: (event, index) => {
                const incrementText = event.increment === 0 ? '<span class="material-symbols-outlined">nest_clock_farsight_analog</span>' : `+${event.increment}`;
                const detailsText = `${incrementText} ${event.unitType || ''}`;
                return `
                    <div class="flex items-center gap-3 flex-grow">
                        <button onclick="WellTrackApp.events.handleShowEventTypeForm(${index})" class="text-blue-500 hover:text-blue-700">
                            <span class="material-symbols-outlined">edit</span>
                        </button>
                        <div class="">
                            <span>${event.name}
                                <span class="text-xs text-gray-800 ">
                                    ${detailsText}
                                    <span class="material-symbols-outlined">group</span>
                                    ${event.groupType || 'Keine'}
                                </span>
                            </span>
                        </div>
                    </div>
                    <div class="flex items-center">
                        <button onclick="WellTrackApp.events.handleRemoveEventType(${index})" class="text-red-400 hover:text-red-600">
                            <span class="material-symbols-outlined">delete</span>
                        </button>
                    </div>`;
            },
            painModalContent: (partName, viewName) => {
                let buttons = '';
                for (const [level, props] of Object.entries(WellTrackApp.config.PAIN_LEVELS)) {
                     buttons += `<button
                        onclick="WellTrackApp.events.handleSetPainLevel(${level})"
                        class="btn w-full text-lg font-bold py-4 px-4 rounded-xl transition-all"
                        style="background-color:${props.color}; color: ${parseInt(level) > 2 && parseInt(level) < 6 ? 'white' : 'black'}"
                        onmouseover="this.style.filter='brightness(90%)'"
                        onmouseout="this.style.filter='brightness(100%)'"
                        >${props.short} (${props.label})</button>`;
                }
                const title = `Schmerz (${viewName}): <br class="sm:hidden"/> <span class="font-bold">${partName}</span>`;
                return `<h3 class="text-xl font-semibold mb-6 text-center">${title}</h3><div class="grid grid-cols-1 gap-4">${buttons}</div><button onclick="WellTrackApp.render.modal.hide()" class="btn btn-tertiary w-full mt-8">Abbrechen</button>`;
            },
            eventTypeForm: (event = null) => {
                const isEditing = event !== null;
                const name = isEditing ? event.name : '';
                const activity = isEditing ? event.activity : '';
                const increment = isEditing ? event.increment : 1;
                const unitType = isEditing ? event.unitType : '';
                const groupType = isEditing ? event.groupType : '';
                const displayType = isEditing ? event.displayType : 0;

                return `
                    <h3 class="text-2xl font-semibold mb-6 text-center">${isEditing ? 'Ereignisart bearbeiten' : 'Neue Ereignisart'}</h3>
                    <div class="space-y-4 text-left">
                        <div><label for="event-name" class="block mb-1 text-sm font-medium">Bezeichnung</label><input id="event-name" type="text" value="${name}" class="w-full p-2 border border-gray-300 rounded-lg" placeholder="z.B. Tassen Kaffee"></div>
                        <div><label for="event-activity" class="block mb-1 text-sm font-medium">Aktivität-ID</label><input id="event-activity" type="text" value="${activity}" ${isEditing ? 'disabled' : ''} class="w-full p-2 border border-gray-300 rounded-lg ${isEditing ? 'bg-gray-100' : ''}" placeholder="z.B. kaffee_tassen"></div>
                        <div class="grid grid-cols-2 gap-4">
                            <div><label for="event-increment" class="block mb-1 text-sm font-medium">Inkrement (0=Zeitstempel)</label><input id="event-increment" type="number" value="${increment}" class="w-full p-2 border border-gray-300 rounded-lg" placeholder="1"></div>
                            <div><label for="event-unit" class="block mb-1 text-sm font-medium">Einheit</label><input id="event-unit" type="text" value="${unitType}" class="w-full p-2 border border-gray-300 rounded-lg" placeholder="min, x, etc."></div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="event-group" class="block mb-1 text-sm font-medium">Gruppe (optional)</label>
                                <input id="event-group" type="text" value="${groupType}" class="w-full p-2 border border-gray-300 rounded-lg" placeholder="z.B. Medikamente">
                            </div>
                            <div>
                                <label for="event-display-type" class="block mb-1 text-sm font-medium">Anzeige-Art</label>
                                <select id="event-display-type" class="w-full p-2 border border-gray-300 rounded-lg">
                                    <option value="0" ${displayType === 0 ? 'selected' : ''}>Gruppiert</option>
                                    <option value="1" ${displayType === 1 ? 'selected' : ''}>Heute+Verlauf</option>
                                    <option value="2" ${displayType === 2 ? 'selected' : ''}>Verlauf</option>
                                    <option value="3" ${displayType === 3 ? 'selected' : ''}>Nur Speichern</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-end gap-4 mt-8">
                        <button onclick="WellTrackApp.events.handleHideEventTypeForm()" class="btn btn-tertiary">Abbrechen</button>
                        <button onclick="WellTrackApp.events.handleSaveEventType()" class="btn btn-primary">Speichern</button>
                    </div>
                `;
            },
            moodSlider: (question) => `
                <div>
                    <div class="flex justify-between items-center text-center mb-2">
                        <span class="w-1/3 text-base text-gray-600 text-left font-medium">${question.negative}</span>
                        <label class="w-1/3 text-gray-800 font-bold">${question.name}</label>
                        <span class="w-1/3 text-base text-gray-600 text-right font-medium">${question.positive}</span>
                    </div>
                    <div class="mood-slider-wrapper"
                         onmousedown="WellTrackApp.events.handleMoodRulerMouseDown(event)"
                         onmouseup="WellTrackApp.events.handleMoodRulerMouseUp(event, '${question.id}')">
                        <div class="mood-slider-ruler"></div>
                        <div class="mood-slider-tick-container">
                            ${Array.from({length: 6}).map(() => `<div class="mood-slider-tick"></div>`).join('')}
                        </div>
                        <input type="range" min="0" max="5" step="1" value="2.5" class="mood-slider w-full is-default" id="mood-slider-${question.id}" oninput="this.classList.remove('is-default')" onpointerdown="WellTrackApp.events.handleMoodRulerMouseDown(event)" onchange="WellTrackApp.events.handleMoodChange('${question.id}')">
                        <div class="mood-slider-default-indicator">
                             <span class="material-symbols-outlined text-3xl" style="font-variation-settings: 'FILL' 1">star</span>
                        </div>
                    </div>
                </div>`
        }
    },

    // --- EVENT HANDLING ---
    events: {
        registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js').then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    }, err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
                });
            }
        },
        showPage(pageName) {
            WellTrackApp.state.activePage = pageName;

            document.querySelectorAll('#header-left .nav-btn, #main-nav .nav-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `nav-${pageName}`);
            });

            const appContainer = document.getElementById('app-container');
            if (pageName === 'history') {
                appContainer.classList.remove('max-w-4xl');
            } else {
                appContainer.classList.add('max-w-4xl');
            }

            switch(pageName) {
                case 'today': WellTrackApp.render.todayPage(); break;
                case 'event': WellTrackApp.render.eventPage(); break;
                case 'mood': WellTrackApp.render.moodPage(); break;
                case 'pain': WellTrackApp.render.painPage(); break;
                case 'settings': WellTrackApp.render.settingsPage(); break;
                case 'history': WellTrackApp.render.historyPage(); break;
                case 'log': WellTrackApp.render.fullLogPage(); break;
            }
        },
        initEventListeners() {
            const observer = new IntersectionObserver((entries) => {
                const btn = document.getElementById('scroll-to-top');
                if(!btn) return;
                if (entries[0].boundingClientRect.y < 0) { btn.classList.remove('opacity-0', 'translate-y-4'); } 
                else { btn.classList.add('opacity-0', 'translate-y-4'); }
            }, { threshold: 0.1 });
            observer.observe(document.querySelector('header'));

        },
        handleBodyPartClick(event) {
            const frontView = document.getElementById('body-front');
            const view = frontView.classList.contains('hidden') ? 'back' : 'front';
            WellTrackApp.render.modal.showPainSelector(event.target, view);
        },
        handlePainFreeClick() {
            let metrics = WellTrackApp.data.getMetrics();
            const now = Date.now();
            const tenMinutesAgo = now - 600000;

            // Check if a pain_free entry exists in the last 10 mins
            const existingPainFreeIndex = metrics.findIndex(m =>
                m.metric === 'pain_free_level' && m.timestamp >= tenMinutesAgo
            );

            if (existingPainFreeIndex > -1) {
                // If it exists, toggle it OFF by removing it.
                metrics.splice(existingPainFreeIndex, 1);
            } else {
                // If it doesn't exist, toggle it ON.
                // 1. Remove all other pain_* entries from the last 10 mins.
                metrics = metrics.filter(m =>
                    !(m.metric.startsWith('pain_') && m.timestamp >= tenMinutesAgo)
                );
                // 2. Add the new pain_free_level entry.
                metrics.push({
                    metric: 'pain_free_level',
                    timestamp: now,
                    labels: { name: 'Schmerz Frei' },
                    value: 0
                });
            }

            WellTrackApp.data.saveMetrics(metrics);
            WellTrackApp.data.loadTodaysState(); // Reload UI
        },
        handleSetPainLevel(level) {
            const part = WellTrackApp.state.currentPainPart; if (!part) return;
            
            let metrics = WellTrackApp.data.getMetrics();
            const now = Date.now();
            const tenMinutesAgo = now - 600000;
            const existingPainFreeIndex = metrics.findIndex(m =>
                m.metric === 'pain_free_level' && m.timestamp >= tenMinutesAgo
            );
            if (existingPainFreeIndex > -1) {
                metrics.splice(existingPainFreeIndex, 1);
                WellTrackApp.data.saveMetrics(metrics);
            }

            const newEntry = {
                metric: `pain_${part.id}_level`,
                timestamp: now,
                labels: { body_part: part.id, name: part.dataset.name }, 
                value: parseInt(level, 10)
            };

            WellTrackApp.data.addMetric(newEntry);

            // Update UI immediately
            if (level === 0) {
                 part.style.fill = WellTrackApp.config.DEFAULT_BODY_COLOR; 
                 delete part.dataset.level; 
            } else { 
                part.style.fill = WellTrackApp.config.PAIN_LEVELS[level].color; 
                part.dataset.level = level; 
            }
            
            WellTrackApp.data.loadTodaysState(); // to update timestamp
            WellTrackApp.render.modal.hide();
        },
        handleEventIncrement(activity, increment) {
            const eventType = WellTrackApp.data.getEventTypes().find(t => t.activity === activity);
            if (!eventType) return;

            let allMetrics = WellTrackApp.data.getMetrics();

            const startOfToday = new Date();
            startOfToday.setHours(0, 0, 0, 0);

            const todaysEntry = allMetrics.find(m =>
                m.labels.activity === activity &&
                m.timestamp >= startOfToday.getTime()
            );

            const currentValue = todaysEntry ? todaysEntry.value : 0;
            const newValue = currentValue + increment;
            
            const newEntry = {
                metric: `event_${activity}_value`,
                timestamp: Date.now(),
                labels: { activity: eventType.activity, name: eventType.name, unitType: eventType.unitType, groupType: eventType.groupType || '' },
                value: newValue
            };

            WellTrackApp.data.addMetric(newEntry);
            
            // Re-render the list to update the value
            WellTrackApp.render.eventListByGroup(WellTrackApp.state.activeEventGroup);
        },
        handleTimestampEvent(activity) {
            const eventType = WellTrackApp.data.getEventTypes().find(e => e.activity === activity);
            if (!eventType) return;

            const newEntry = {
                metric: `event_${activity}_timestamp`,
                timestamp: Date.now(),
                labels: { activity: eventType.activity, name: eventType.name, unitType: eventType.unitType, groupType: eventType.groupType || '' },
                value: 1 // Value is 1 to be countable
            };
            WellTrackApp.data.addMetric(newEntry);
            WellTrackApp.render.eventListByGroup(WellTrackApp.state.activeEventGroup);
        },
        handleUndoTimestamp(activity) {
            let metrics = WellTrackApp.data.getMetrics();

            const startOfToday = new Date();
            startOfToday.setHours(0, 0, 0, 0);

            // Find the last timestamp entry for this activity today
            let lastEntryIndex = -1;
            for(let i = metrics.length - 1; i >= 0; i--) {
                const entry = metrics[i];
                if (entry.labels.activity === activity && entry.metric.endsWith('_timestamp') && entry.timestamp >= startOfToday.getTime()) {
                    lastEntryIndex = i;
                    break;
                }
            }

            if (lastEntryIndex > -1) {
                metrics.splice(lastEntryIndex, 1);
                WellTrackApp.data.saveMetrics(metrics);
                WellTrackApp.render.eventListByGroup(WellTrackApp.state.activeEventGroup);
            }
        },
        handleWeekChange(direction) {
            let newWeekStart;
            const currentStart = WellTrackApp.state.currentLogWeekStart;

            if (direction === 'next') {
                newWeekStart = dateFns.addWeeks(currentStart, 1);
            } else if (direction === 'prev') {
                newWeekStart = dateFns.subWeeks(currentStart, 1);
            } else if (direction === 'today') {
                newWeekStart = WellTrackApp.utils.getStartOfWeek(new Date());
            } else if (direction === 'first') {
                const allMetrics = WellTrackApp.data.getMetrics();
                if (allMetrics.length > 0) {
                    const earliestEntry = allMetrics[0].timestamp; // Assumes metrics are sorted
                    newWeekStart = WellTrackApp.utils.getStartOfWeek(new Date(earliestEntry));
                } else {
                    newWeekStart = WellTrackApp.utils.getStartOfWeek(new Date());
                }
            }

            if (newWeekStart) {
                WellTrackApp.state.currentLogWeekStart = newWeekStart;
                WellTrackApp.render.fullLogPage();
            }
        },
        handleViewToggle(view) {
            WellTrackApp.state.currentPainView = view;
            const settings = WellTrackApp.data.getSettings();
            settings.painView = view;
            WellTrackApp.data.saveSettings(settings);
            document.getElementById('body-front').classList.toggle('hidden', view !== 'front');
            document.getElementById('body-back').classList.toggle('hidden', view === 'front');
            document.getElementById('btn-view-front').classList.toggle('active', view === 'front');
            document.getElementById('btn-view-back').classList.toggle('active', view !== 'front');
        },
        handleTimeRangeChange(event) {
            WellTrackApp.state.timeRange = parseInt(event.target.value, 10);
            WellTrackApp.render.historyPage();
        },
        handleRemoveEventType(index) {
            const eventTypes = WellTrackApp.data.getEventTypes();
            const eventTypeToDelete = eventTypes[index];
            let allMetrics = WellTrackApp.data.getMetrics();

            const usedMetricsCount = allMetrics.filter(metric =>
                metric.labels && metric.labels.activity === eventTypeToDelete.activity
            ).length;

            let message;
            if (usedMetricsCount > 0) {
                 message = `<span class="text-lg">Möchten Sie das Ereignis "${eventTypeToDelete.name}" wirklich entfernen? Es sind ${usedMetricsCount} Einträge dieser Art vorhanden, die ebenfalls gelöscht werden.</span>`;
            } else {
                 message = `<span class="text-lg">Möchten Sie das Ereignis "${eventTypeToDelete.name}" wirklich entfernen? Es gibt keine Einträge dieser Art.</span>`;
            }

            WellTrackApp.render.modal.showConfirmation('Ereignis löschen', message, () => {
                // Remove the event type
                eventTypes.splice(index, 1);
                WellTrackApp.data.saveEventTypes(eventTypes);

                // Remove the associated metrics if any
                if (usedMetricsCount > 0) {
                    const newMetrics = allMetrics.filter(metric =>
                        !metric.labels || metric.labels.activity !== eventTypeToDelete.activity
                    );
                    WellTrackApp.data.saveMetrics(newMetrics);
                }

                // Re-render UI
                WellTrackApp.render.settingsPage();
                if (['event', 'today', 'history', 'log'].includes(WellTrackApp.state.activePage)) {
                    WellTrackApp.events.showPage(WellTrackApp.state.activePage);
                }
            }, { confirmText: 'Löschen', abortText: 'Abbrechen', modalClass: 'max-w-lg' });
        },
        handleToggleDay(event) {
            const button = event.target.closest('.day-btn');
            if (button) {
                button.classList.toggle('selected');
            }
        },
        handleSaveEventType() {
            const name = document.getElementById('event-name').value.trim();
            const eventTypes = WellTrackApp.data.getEventTypes();
            const isEditing = !!WellTrackApp.state.currentEditingEvent;

            // Get activity from state if editing, otherwise from form for a new event.
            // This is more robust than reading from a disabled form field.
            const activity = isEditing
                ? WellTrackApp.state.currentEditingEvent.activity
                : WellTrackApp.utils.slugify(document.getElementById('event-activity').value.trim());

            const increment = parseInt(document.getElementById('event-increment').value, 10);
            const unitType = document.getElementById('event-unit').value.trim();
            const groupType = document.getElementById('event-group').value.trim();
            const displayType = parseInt(document.getElementById('event-display-type').value, 10);

            if (!name || !activity) {
                WellTrackApp.render.modal.showAlert('Fehler', 'Bezeichnung und Aktivität-ID sind erforderlich.');
                return;
            }

            if (!isEditing && eventTypes.some(t => t.activity === activity)) {
                WellTrackApp.render.modal.showAlert('Fehler', 'Diese Aktivität-ID wird bereits verwendet.');
                return;
            }

            const newEventData = { name, activity, increment, unitType, groupType, displayType };

            if (isEditing) {
                const index = eventTypes.findIndex(t => t.activity === activity);
                if (index > -1) {
                    eventTypes[index] = newEventData;
                }
            } else {
                eventTypes.push(newEventData);
            }

            WellTrackApp.data.saveEventTypes(eventTypes);
            this.handleHideEventTypeForm(); // This will now close the modal
            WellTrackApp.render.manageEventList();
            if(WellTrackApp.state.activePage === 'event') WellTrackApp.render.eventPage();
        },
        handleShowEventTypeForm(index = null) {
            const eventType = index !== null ? WellTrackApp.data.getEventTypes()[index] : null;
            WellTrackApp.state.currentEditingEvent = eventType;
            const formContent = WellTrackApp.render.components.eventTypeForm(eventType);
            WellTrackApp.render.modal.show(formContent, { modalClass: 'w-full max-w-2xl' });
        },
        handleHideEventTypeForm() {
            WellTrackApp.render.modal.hide();
        },
        handleMoodRulerMouseDown(event) {
            WellTrackApp.state.sliderClickStartPosition = {
                x: event.clientX,
                y: event.clientY,
                scrollX: window.scrollX,
                scrollY: window.scrollY
            };
        },
        handleMoodRulerMouseUp(event, moodId) {
            const startPos = WellTrackApp.state.sliderClickStartPosition;
            if (!startPos) return;

            const dx = Math.abs(event.clientX - startPos.x);
            const dy = Math.abs(event.clientY - startPos.y);
            const dScrollX = Math.abs(window.scrollX - startPos.scrollX);
            const dScrollY = Math.abs(window.scrollY - startPos.scrollY);

            WellTrackApp.state.sliderClickStartPosition = null; // Reset for next time

            // If mouse moved more than a threshold OR the page scrolled, it was a drag/scroll.
            if (dx > 5 || dy > 5 || dScrollX > 0 || dScrollY > 0) {
                return;
            }

            // It was a true click, execute the original logic.
            if (event.target.type === 'range') return;
            const slider = document.getElementById(`mood-slider-${moodId}`);
            const rect = event.currentTarget.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const width = rect.width;
            
            const clickPercentage = clickX / width;
            const step = Math.round(clickPercentage * 5);

            slider.value = step;
            slider.classList.remove('is-default');
            
            const changeEvent = new Event('change');
            slider.dispatchEvent(changeEvent);
        },
        handleMoodChange(moodId) {
            const startPos = WellTrackApp.state.sliderClickStartPosition;
            if (startPos) {
                const dScrollY = Math.abs(window.scrollY - startPos.scrollY);
                const dScrollX = Math.abs(window.scrollX - startPos.scrollX);
                if (dScrollX > 0 || dScrollY > 0) {
                    WellTrackApp.state.sliderClickStartPosition = null; // Reset state
                    return; // Abort change if scroll was detected
                }
            }
            WellTrackApp.state.sliderClickStartPosition = null; // Reset state on successful change

            const slider = document.getElementById(`mood-slider-${moodId}`);
            if (!slider) return;

            const sliderValue = parseInt(slider.value, 10);
            const value = WellTrackApp.config.MOOD_VALUE_MAP[sliderValue];

            let question;
            for (const groupKey in WellTrackApp.config.MOOD_GROUPS) {
                const found = WellTrackApp.config.MOOD_GROUPS[groupKey].questions.find(q => q.id === moodId);
                if (found) { question = found; break; }
            }
            if(!question) return;

            const newEntry = {
                metric: `mood_${moodId}_level`,
                timestamp: Date.now(),
                labels: { mood_id: moodId, name: question.name },
                value: value
            };
            
            WellTrackApp.data.addMetric(newEntry);
            WellTrackApp.data.loadTodaysState(); // to update timestamp
        },
        handleMoodGroupToggle(groupId) {
            WellTrackApp.state.activeMoodGroup = groupId;
            WellTrackApp.render.moodPage();
        },
        handleEventGroupToggle(groupType) {
            WellTrackApp.state.activeEventGroup = groupType;
            WellTrackApp.render.eventPage();
        },
        showEventPageForGroup(groupKey) {
            WellTrackApp.state.activeEventGroup = groupKey;
            this.showPage('event');
        },
        showHistoryFor(tabName) {
            this.showPage('history');
            // Use a timeout to ensure the page is rendered before clicking the tab
            setTimeout(() => {
                const tabButton = document.querySelector(`#history-tabs .history-tab[data-tab='${tabName}']`);
                if (tabButton) {
                    tabButton.click();
                }
            }, 0);
        },
        showHistoryForEvent(chartKey) {
            this.showPage('history');
            setTimeout(() => {
                const tabButton = document.querySelector(`#history-tabs .history-tab[data-tab='event']`);
                if (tabButton) {
                    tabButton.click();
                }
                const chartCanvas = WellTrackApp.state.charts[chartKey]?.canvas;
                if (chartCanvas) {
                    chartCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        },
        handleHistoryTabClick(tabName, shouldAnimate = true) {
            WellTrackApp.state.activeHistoryTab = tabName;
            
            document.querySelectorAll('.history-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            
            document.querySelectorAll('.chart-container').forEach(container => {
                container.classList.toggle('hidden', container.id !== `chart-container-${tabName}`);
            });
        },
        handleSettingsTabClick(tabName) {
            WellTrackApp.state.activeSettingsTab = tabName;
            const settings = WellTrackApp.data.getSettings();
            settings.activeSettingsTab = tabName;
            WellTrackApp.data.saveSettings(settings);
            WellTrackApp.render.settingsPage();
        },
        toggleTodaysLog() {
            WellTrackApp.state.isTodaysLogVisible = !WellTrackApp.state.isTodaysLogVisible;
            const settings = WellTrackApp.data.getSettings();
            settings.logVisibility = WellTrackApp.state.isTodaysLogVisible;
            WellTrackApp.data.saveSettings(settings);
            WellTrackApp.render.todayPage();
        },
        async requestNotificationPermission() {
            const permission = await Notification.requestPermission();
            WellTrackApp.state.notificationPermission = permission;
            WellTrackApp.render.settingsPage(); // Re-render page to show new state
        },
        saveReminderTimes(timesString) {
            const settings = WellTrackApp.data.getSettings();
            settings.reminderTimes = timesString.trim();
            WellTrackApp.data.saveSettings(settings);
        },
        handleActivateReminders() {
            const settings = WellTrackApp.data.getSettings();
            settings.reminders_active = true;
            WellTrackApp.data.saveSettings(settings);
            WellTrackApp.render.settingsPage();
        },
        handleDeactivateReminders() {
            const settings = WellTrackApp.data.getSettings();
            settings.reminders_active = false;
            WellTrackApp.data.saveSettings(settings);
            WellTrackApp.render.settingsPage();
        },
        showTestNotification() {
            if (WellTrackApp.state.notificationPermission === 'granted') {
                navigator.serviceWorker.getRegistration().then(reg => {
                    if (reg) {
                        reg.showNotification('WellTrack Erinnerung', {
                            body: 'Zeit für einen neuen Tagebucheintrag!',
                            icon: 'icon-192.png'
                        });
                    } else {
                       WellTrackApp.render.modal.showAlert('Fehler', 'Service Worker nicht gefunden. Die Benachrichtigung kann nicht gesendet werden.')
                    }
                });
            } else {
                 WellTrackApp.render.modal.showAlert('Fehler', 'Die Berechtigung für Benachrichtigungen wurde nicht erteilt.')
            }
        },
        handleDeleteAllData() {
            WellTrackApp.render.modal.showConfirmation(
                'Alle Daten löschen',
                'Sind Sie sicher, dass Sie alle ihre Einträge und Einstellungen unwiderruflich löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.',
                () => {
                    localStorage.removeItem('wellTrackMetrics');
                    localStorage.removeItem('wellTrackEventTypes');
                    localStorage.removeItem('wellTrackSettings');
                    WellTrackApp.events.showNotification("Alle Daten gelöscht", "delete_forever");
                    // Manually reset app state and re-render without a full page reload
                    location.reload();
                },
                { confirmText: 'Löschen', abortText: 'Abbrechen' }
            );
        },
        showNotification(message, icon = 'info', duration = 4000) {
            const overlay = document.getElementById('notification-overlay');
            const overlayText = document.getElementById('notification-overlay-text');
            const overlayIcon = document.getElementById('notification-overlay-icon');

            overlayText.textContent = message;
            overlayIcon.textContent = icon;
            overlay.classList.remove('hidden');

            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    overlay.style.opacity = '1'; // Reset for next time
                }, 500);
            }, duration);
        },
        checkVersion() {
            const lastModified = document.lastModified;
            let settings = WellTrackApp.data.getSettings();

            if (lastModified && settings.welltrack_latest !== lastModified) {
                const formattedDate = new Date(lastModified).toLocaleString('de-DE', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                const overlay = document.getElementById('version-overlay');
                const overlayText = document.getElementById('version-overlay-text');

                overlayText.textContent = `Aktualisiert, Version ${formattedDate}`;
                overlay.classList.remove('hidden');

                setTimeout(() => {
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        overlay.classList.add('hidden');
                        overlay.style.opacity = '1'; // Reset for next time
                    }, 500);
                }, 4000);

                settings.welltrack_latest = lastModified;
                WellTrackApp.data.saveSettings(settings);
            }
        }
    },

    // --- UTILITIES ---
    utils: {
        isSameDay(d1, d2) {
            return d1.getFullYear() === d2.getFullYear() &&
                   d1.getMonth() === d2.getMonth() &&
                   d1.getDate() === d2.getDate();
        },
        isToday(date) {
            return this.isSameDay(date, new Date());
        },
        getStartOfWeek(date) {
            return dateFns.startOfWeek(date, { weekStartsOn: 1 });
        },
        formatWeekRange(startDate) {
            if (!startDate) return '';
            const endDate = dateFns.endOfWeek(startDate, { weekStartsOn: 1 });
            const startFormat = 'dd.MM';
            const endFormat = 'dd.MM';
            return `${dateFns.format(startDate, startFormat)}-${dateFns.format(endDate, endFormat)}`;
        },
        slugify(text) {
            return text.toString().toLowerCase()
                .replace(/\s+/g, '_')       // Replace spaces with _
                .replace(/[^\w_]+/g, '')    // Remove all non-word chars except _
                .replace(/__+/g, '_')       // Replace multiple _ with single _
                .replace(/^_+/, '')         // Trim _ from start of text
                .replace(/_+$/, '');        // Trim _ from end of text
        },
        simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) { const char = str.charCodeAt(i); hash = (hash << 5) - hash + char; hash |= 0; }
            return Math.abs(hash);
        },
        generateColorFromHash(str, opacity = 1) {
            const hash = this.simpleHash(str);
            const r = (hash & 0xFF0000) >> 16; const g = (hash & 0x00FF00) >> 8; const b = hash & 0x0000FF;
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        },
        getMetricSlots(metricPrefix) {
            const metrics = WellTrackApp.data.getMetrics().filter(m => m.metric.startsWith(metricPrefix));
            if (metrics.length === 0) {
                return { latestSlot: null, previousSlot: null };
            }

            const getSlotValue = (slotMetrics) => slotMetrics.reduce((sum, m) => sum + m.value, 0);

            // Find the latest slot
            const latestEntry = metrics[metrics.length - 1];
            const slotEndTime = latestEntry.timestamp;
            const slotStartTime = slotEndTime - 600000; // 10 minutes

            const latestSlotMetrics = metrics.filter(m => m.timestamp >= slotStartTime && m.timestamp <= slotEndTime);
            const latestSlotValue = getSlotValue(latestSlotMetrics);

            // Find the previous slot
            const remainingMetrics = metrics.filter(m => m.timestamp < slotStartTime);
            if (remainingMetrics.length === 0) {
                return { latestSlot: latestSlotValue, previousSlot: null };
            }

            const previousEntry = remainingMetrics[remainingMetrics.length - 1];
            const prevSlotEndTime = previousEntry.timestamp;
            const prevSlotStartTime = prevSlotEndTime - 600000; // 10 minutes

            const previousSlotMetrics = remainingMetrics.filter(m => m.timestamp >= prevSlotStartTime && m.timestamp <= prevSlotEndTime);
            const previousSlotValue = getSlotValue(previousSlotMetrics);

            return { latestSlot: latestSlotValue, previousSlot: previousSlotValue };
        },
        summarizeMetrics(metrics) {
            const summarized = {};
            // Create a copy to sort without mutating the original
            const sortedMetrics = [...metrics].sort((a, b) => a.timestamp - b.timestamp);

            sortedMetrics.forEach((metric, index) => {
                if (metric.metric.startsWith('event_') && !metric.metric.endsWith('_timestamp')) {
                    const key = `event-${metric.labels.activity}`;
                    if (!summarized[key]) {
                        summarized[key] = { ...metric, value: 0 };
                    }
                    summarized[key].value += metric.value;
                    summarized[key].timestamp = metric.timestamp;
                } else {
                    const key = metric.timestamp + metric.metric + index;
                    summarized[key] = metric;
                }
            });
            return Object.values(summarized);
        },
        getDailyChartData(metricPrefix, filterFunc = () => true) {
            const data = WellTrackApp.data.getMetrics();
            const timeRangeDays = WellTrackApp.state.timeRange || 7;
            const startDate = new Date(); startDate.setHours(0, 0, 0, 0); startDate.setDate(startDate.getDate() - (timeRangeDays - 1));
            
            const filteredData = data.filter(entry => {
                const entryDate = new Date(entry.timestamp);
                return entry.metric.startsWith(metricPrefix) &&
                       entryDate >= startDate &&
                       filterFunc(entry);
            });

            const dailyTotals = filteredData.reduce((acc, entry) => {
                let dayKey;
                if (metricPrefix === 'mood_' || metricPrefix === 'pain_') {
                    const timestamp = new Date(entry.timestamp);
                    const minutes = timestamp.getMinutes();
                    const roundedMinutes = Math.floor(minutes / 10) * 10;
                    timestamp.setMinutes(roundedMinutes, 0, 0);
                    dayKey = timestamp.getTime();
                } else {
                    const d = new Date(entry.timestamp);
                    d.setHours(0, 0, 0, 0);
                    dayKey = d.getTime();
                }

                if (!acc[dayKey]) acc[dayKey] = { total: 0, positiveSum: 0, negativeSum: 0, values: {}, details: {} };
                
                const labelName = entry.labels.name;
                if (!acc[dayKey].values[labelName]) {
                    acc[dayKey].values[labelName] = 0;
                    acc[dayKey].details[labelName] = [];
                }
                
                const valueToAdd = entry.metric.endsWith('_timestamp') ? 1 : entry.value;
                acc[dayKey].values[labelName] += valueToAdd;
                acc[dayKey].total += valueToAdd;

                if(metricPrefix === 'mood_') {
                    if (valueToAdd > 0) acc[dayKey].positiveSum += valueToAdd;
                    else acc[dayKey].negativeSum += valueToAdd;
                }

                if (entry.metric.endsWith('_timestamp')) {
                    acc[dayKey].details[labelName].push(entry.timestamp);
                }

                return acc;
            }, {});

            const allLabels = [...new Set(filteredData.map(p => p.labels.name))];
            
            const dailyData = Object.entries(dailyTotals).map(([timestamp, data]) => ({
                timestamp: parseInt(timestamp), // Already in MS
                total: data.total,
                positiveSum: data.positiveSum,
                negativeSum: data.negativeSum,
                values: data.values,
                details: data.details
            })).sort((a,b) => a.timestamp - b.timestamp);

            return { dailyData, allLabels };
        },
        calculateMovingAverage(data, metricPrefix, filterFunc = () => true) {
            const timeRange = WellTrackApp.state.timeRange;
            let windowSize;
            if (timeRange <= 7) windowSize = 3;
            else if (timeRange <= 30) windowSize = 7;
            else windowSize = 28;

            if (!data || data.length === 0) return [];
            if (windowSize > data.length) windowSize = data.length;

            const firstVisibleDate = new Date(data[0].x);
            const historicalStartDate = new Date(firstVisibleDate);
            historicalStartDate.setDate(firstVisibleDate.getDate() - windowSize + 1);

            const lastVisibleDate = new Date(data[data.length - 1].x);

            const dailyAverages = [];
            const allMetrics = WellTrackApp.data.getMetrics().filter(m => m.metric.startsWith(metricPrefix) && filterFunc(m));

            for (let d = new Date(historicalStartDate); d <= lastVisibleDate; d.setDate(d.getDate() + 1)) {
                const day = new Date(d);
                day.setHours(0, 0, 0, 0);
                let dailyAverage = 0;

                if (metricPrefix.startsWith('mood_') || metricPrefix.startsWith('pain_')) {
                    const startOfDay = day.getTime();
                    const endOfDay = startOfDay + (24 * 60 * 60 * 1000) - 1;

                    const metricsBefore = allMetrics
                        .filter(m => m.timestamp < startOfDay)
                        .sort((a, b) => b.timestamp - a.timestamp);
                    const lastValue = metricsBefore.length > 0 ? metricsBefore[0].value : 0;

                    let dayMetrics = allMetrics
                        .filter(m => m.timestamp >= startOfDay && m.timestamp <= endOfDay)
                        .sort((a, b) => a.timestamp - b.timestamp);

                    if (metricPrefix.startsWith('pain_') && dayMetrics.length === 0) {
                        const noon = new Date(day);
                        noon.setHours(12, 0, 0, 0);
                        dayMetrics.push({ timestamp: noon.getTime(), value: 0 });
                    }

                    const pointsInTime = [{ timestamp: startOfDay, value: lastValue }, ...dayMetrics];

                    if (pointsInTime.length === 1) {
                        dailyAverage = lastValue;
                    } else {
                        let weightedSum = 0;
                        for (let i = 0; i < pointsInTime.length; i++) {
                            const currentPoint = pointsInTime[i];
                            const nextTimestamp = (i + 1 < pointsInTime.length) ? pointsInTime[i + 1].timestamp : endOfDay + 1;
                            const duration = nextTimestamp - currentPoint.timestamp;
                            weightedSum += currentPoint.value * duration;
                        }
                        dailyAverage = weightedSum / (endOfDay - startOfDay + 1);
                    }
                } else { // Events
                    const startOfDay = day.getTime();
                    const endOfDay = startOfDay + (24 * 60 * 60 * 1000) - 1;
                    const dayMetrics = allMetrics.filter(m => m.timestamp >= startOfDay && m.timestamp <= endOfDay);
                    dailyAverage = dayMetrics.reduce((sum, m) => sum + (m.value || 0), 0);
                }
                dailyAverages.push({ x: day.getTime(), y: dailyAverage });
            }

            const movingAverages = [];
            if (dailyAverages.length < windowSize) return [];

            for (let i = windowSize - 1; i < dailyAverages.length; i++) {
                const windowSlice = dailyAverages.slice(i - windowSize + 1, i + 1);
                const sum = windowSlice.reduce((acc, val) => acc + val.y, 0);
                const sma = sum / windowSize;
                movingAverages.push({
                    x: dailyAverages[i].x,
                    y: parseFloat(sma.toFixed(2))
                });
            }
            return movingAverages;
        }
    }
};

WellTrackApp.init();

</script>
</body>
</html>

